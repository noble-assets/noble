// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cctp/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgUpdateAuthority struct {
	From         string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	NewAuthority string `protobuf:"bytes,2,opt,name=new_authority,json=newAuthority,proto3" json:"new_authority,omitempty"`
}

func (m *MsgUpdateAuthority) Reset()         { *m = MsgUpdateAuthority{} }
func (m *MsgUpdateAuthority) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateAuthority) ProtoMessage()    {}
func (*MsgUpdateAuthority) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{0}
}
func (m *MsgUpdateAuthority) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateAuthority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateAuthority.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateAuthority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateAuthority.Merge(m, src)
}
func (m *MsgUpdateAuthority) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateAuthority) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateAuthority.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateAuthority proto.InternalMessageInfo

func (m *MsgUpdateAuthority) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgUpdateAuthority) GetNewAuthority() string {
	if m != nil {
		return m.NewAuthority
	}
	return ""
}

type MsgUpdateAuthorityResponse struct {
}

func (m *MsgUpdateAuthorityResponse) Reset()         { *m = MsgUpdateAuthorityResponse{} }
func (m *MsgUpdateAuthorityResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateAuthorityResponse) ProtoMessage()    {}
func (*MsgUpdateAuthorityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{1}
}
func (m *MsgUpdateAuthorityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateAuthorityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateAuthorityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateAuthorityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateAuthorityResponse.Merge(m, src)
}
func (m *MsgUpdateAuthorityResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateAuthorityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateAuthorityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateAuthorityResponse proto.InternalMessageInfo

type MsgAddPublicKey struct {
	From      string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	PublicKey []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
}

func (m *MsgAddPublicKey) Reset()         { *m = MsgAddPublicKey{} }
func (m *MsgAddPublicKey) String() string { return proto.CompactTextString(m) }
func (*MsgAddPublicKey) ProtoMessage()    {}
func (*MsgAddPublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{2}
}
func (m *MsgAddPublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddPublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddPublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddPublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddPublicKey.Merge(m, src)
}
func (m *MsgAddPublicKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddPublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddPublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddPublicKey proto.InternalMessageInfo

func (m *MsgAddPublicKey) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgAddPublicKey) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type MsgAddPublicKeyResponse struct {
}

func (m *MsgAddPublicKeyResponse) Reset()         { *m = MsgAddPublicKeyResponse{} }
func (m *MsgAddPublicKeyResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddPublicKeyResponse) ProtoMessage()    {}
func (*MsgAddPublicKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{3}
}
func (m *MsgAddPublicKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddPublicKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddPublicKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddPublicKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddPublicKeyResponse.Merge(m, src)
}
func (m *MsgAddPublicKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddPublicKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddPublicKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddPublicKeyResponse proto.InternalMessageInfo

type MsgRemovePublicKey struct {
	From      string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	PublicKey []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
}

func (m *MsgRemovePublicKey) Reset()         { *m = MsgRemovePublicKey{} }
func (m *MsgRemovePublicKey) String() string { return proto.CompactTextString(m) }
func (*MsgRemovePublicKey) ProtoMessage()    {}
func (*MsgRemovePublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{4}
}
func (m *MsgRemovePublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemovePublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemovePublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemovePublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemovePublicKey.Merge(m, src)
}
func (m *MsgRemovePublicKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemovePublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemovePublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemovePublicKey proto.InternalMessageInfo

func (m *MsgRemovePublicKey) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgRemovePublicKey) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type MsgRemovePublicKeyResponse struct {
}

func (m *MsgRemovePublicKeyResponse) Reset()         { *m = MsgRemovePublicKeyResponse{} }
func (m *MsgRemovePublicKeyResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemovePublicKeyResponse) ProtoMessage()    {}
func (*MsgRemovePublicKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{5}
}
func (m *MsgRemovePublicKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemovePublicKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemovePublicKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemovePublicKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemovePublicKeyResponse.Merge(m, src)
}
func (m *MsgRemovePublicKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemovePublicKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemovePublicKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemovePublicKeyResponse proto.InternalMessageInfo

type MsgPauseBurningAndMinting struct {
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
}

func (m *MsgPauseBurningAndMinting) Reset()         { *m = MsgPauseBurningAndMinting{} }
func (m *MsgPauseBurningAndMinting) String() string { return proto.CompactTextString(m) }
func (*MsgPauseBurningAndMinting) ProtoMessage()    {}
func (*MsgPauseBurningAndMinting) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{6}
}
func (m *MsgPauseBurningAndMinting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPauseBurningAndMinting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPauseBurningAndMinting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPauseBurningAndMinting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPauseBurningAndMinting.Merge(m, src)
}
func (m *MsgPauseBurningAndMinting) XXX_Size() int {
	return m.Size()
}
func (m *MsgPauseBurningAndMinting) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPauseBurningAndMinting.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPauseBurningAndMinting proto.InternalMessageInfo

func (m *MsgPauseBurningAndMinting) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

type MsgPauseBurningAndMintingResponse struct {
}

func (m *MsgPauseBurningAndMintingResponse) Reset()         { *m = MsgPauseBurningAndMintingResponse{} }
func (m *MsgPauseBurningAndMintingResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPauseBurningAndMintingResponse) ProtoMessage()    {}
func (*MsgPauseBurningAndMintingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{7}
}
func (m *MsgPauseBurningAndMintingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPauseBurningAndMintingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPauseBurningAndMintingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPauseBurningAndMintingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPauseBurningAndMintingResponse.Merge(m, src)
}
func (m *MsgPauseBurningAndMintingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPauseBurningAndMintingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPauseBurningAndMintingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPauseBurningAndMintingResponse proto.InternalMessageInfo

type MsgUnpauseBurningAndMinting struct {
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
}

func (m *MsgUnpauseBurningAndMinting) Reset()         { *m = MsgUnpauseBurningAndMinting{} }
func (m *MsgUnpauseBurningAndMinting) String() string { return proto.CompactTextString(m) }
func (*MsgUnpauseBurningAndMinting) ProtoMessage()    {}
func (*MsgUnpauseBurningAndMinting) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{8}
}
func (m *MsgUnpauseBurningAndMinting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUnpauseBurningAndMinting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUnpauseBurningAndMinting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUnpauseBurningAndMinting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUnpauseBurningAndMinting.Merge(m, src)
}
func (m *MsgUnpauseBurningAndMinting) XXX_Size() int {
	return m.Size()
}
func (m *MsgUnpauseBurningAndMinting) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUnpauseBurningAndMinting.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUnpauseBurningAndMinting proto.InternalMessageInfo

func (m *MsgUnpauseBurningAndMinting) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

type MsgUnpauseBurningAndMintingResponse struct {
}

func (m *MsgUnpauseBurningAndMintingResponse) Reset()         { *m = MsgUnpauseBurningAndMintingResponse{} }
func (m *MsgUnpauseBurningAndMintingResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUnpauseBurningAndMintingResponse) ProtoMessage()    {}
func (*MsgUnpauseBurningAndMintingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{9}
}
func (m *MsgUnpauseBurningAndMintingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUnpauseBurningAndMintingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUnpauseBurningAndMintingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUnpauseBurningAndMintingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUnpauseBurningAndMintingResponse.Merge(m, src)
}
func (m *MsgUnpauseBurningAndMintingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUnpauseBurningAndMintingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUnpauseBurningAndMintingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUnpauseBurningAndMintingResponse proto.InternalMessageInfo

type MsgPauseSendingAndReceivingMessages struct {
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
}

func (m *MsgPauseSendingAndReceivingMessages) Reset()         { *m = MsgPauseSendingAndReceivingMessages{} }
func (m *MsgPauseSendingAndReceivingMessages) String() string { return proto.CompactTextString(m) }
func (*MsgPauseSendingAndReceivingMessages) ProtoMessage()    {}
func (*MsgPauseSendingAndReceivingMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{10}
}
func (m *MsgPauseSendingAndReceivingMessages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPauseSendingAndReceivingMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPauseSendingAndReceivingMessages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPauseSendingAndReceivingMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPauseSendingAndReceivingMessages.Merge(m, src)
}
func (m *MsgPauseSendingAndReceivingMessages) XXX_Size() int {
	return m.Size()
}
func (m *MsgPauseSendingAndReceivingMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPauseSendingAndReceivingMessages.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPauseSendingAndReceivingMessages proto.InternalMessageInfo

func (m *MsgPauseSendingAndReceivingMessages) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

type MsgPauseSendingAndReceivingMessagesResponse struct {
}

func (m *MsgPauseSendingAndReceivingMessagesResponse) Reset() {
	*m = MsgPauseSendingAndReceivingMessagesResponse{}
}
func (m *MsgPauseSendingAndReceivingMessagesResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgPauseSendingAndReceivingMessagesResponse) ProtoMessage() {}
func (*MsgPauseSendingAndReceivingMessagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{11}
}
func (m *MsgPauseSendingAndReceivingMessagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPauseSendingAndReceivingMessagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPauseSendingAndReceivingMessagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPauseSendingAndReceivingMessagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPauseSendingAndReceivingMessagesResponse.Merge(m, src)
}
func (m *MsgPauseSendingAndReceivingMessagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPauseSendingAndReceivingMessagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPauseSendingAndReceivingMessagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPauseSendingAndReceivingMessagesResponse proto.InternalMessageInfo

type MsgUnpauseSendingAndReceivingMessages struct {
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
}

func (m *MsgUnpauseSendingAndReceivingMessages) Reset()         { *m = MsgUnpauseSendingAndReceivingMessages{} }
func (m *MsgUnpauseSendingAndReceivingMessages) String() string { return proto.CompactTextString(m) }
func (*MsgUnpauseSendingAndReceivingMessages) ProtoMessage()    {}
func (*MsgUnpauseSendingAndReceivingMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{12}
}
func (m *MsgUnpauseSendingAndReceivingMessages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUnpauseSendingAndReceivingMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUnpauseSendingAndReceivingMessages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUnpauseSendingAndReceivingMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUnpauseSendingAndReceivingMessages.Merge(m, src)
}
func (m *MsgUnpauseSendingAndReceivingMessages) XXX_Size() int {
	return m.Size()
}
func (m *MsgUnpauseSendingAndReceivingMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUnpauseSendingAndReceivingMessages.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUnpauseSendingAndReceivingMessages proto.InternalMessageInfo

func (m *MsgUnpauseSendingAndReceivingMessages) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

type MsgUnpauseSendingAndReceivingMessagesResponse struct {
}

func (m *MsgUnpauseSendingAndReceivingMessagesResponse) Reset() {
	*m = MsgUnpauseSendingAndReceivingMessagesResponse{}
}
func (m *MsgUnpauseSendingAndReceivingMessagesResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgUnpauseSendingAndReceivingMessagesResponse) ProtoMessage() {}
func (*MsgUnpauseSendingAndReceivingMessagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{13}
}
func (m *MsgUnpauseSendingAndReceivingMessagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUnpauseSendingAndReceivingMessagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUnpauseSendingAndReceivingMessagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUnpauseSendingAndReceivingMessagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUnpauseSendingAndReceivingMessagesResponse.Merge(m, src)
}
func (m *MsgUnpauseSendingAndReceivingMessagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUnpauseSendingAndReceivingMessagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUnpauseSendingAndReceivingMessagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUnpauseSendingAndReceivingMessagesResponse proto.InternalMessageInfo

type MsgUpdateMaxMessageBodySize struct {
	From  string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Size_ uint32 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *MsgUpdateMaxMessageBodySize) Reset()         { *m = MsgUpdateMaxMessageBodySize{} }
func (m *MsgUpdateMaxMessageBodySize) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateMaxMessageBodySize) ProtoMessage()    {}
func (*MsgUpdateMaxMessageBodySize) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{14}
}
func (m *MsgUpdateMaxMessageBodySize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateMaxMessageBodySize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateMaxMessageBodySize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateMaxMessageBodySize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateMaxMessageBodySize.Merge(m, src)
}
func (m *MsgUpdateMaxMessageBodySize) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateMaxMessageBodySize) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateMaxMessageBodySize.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateMaxMessageBodySize proto.InternalMessageInfo

func (m *MsgUpdateMaxMessageBodySize) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgUpdateMaxMessageBodySize) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type MsgUpdateMaxMessageBodySizeResponse struct {
}

func (m *MsgUpdateMaxMessageBodySizeResponse) Reset()         { *m = MsgUpdateMaxMessageBodySizeResponse{} }
func (m *MsgUpdateMaxMessageBodySizeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateMaxMessageBodySizeResponse) ProtoMessage()    {}
func (*MsgUpdateMaxMessageBodySizeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{15}
}
func (m *MsgUpdateMaxMessageBodySizeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateMaxMessageBodySizeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateMaxMessageBodySizeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateMaxMessageBodySizeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateMaxMessageBodySizeResponse.Merge(m, src)
}
func (m *MsgUpdateMaxMessageBodySizeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateMaxMessageBodySizeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateMaxMessageBodySizeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateMaxMessageBodySizeResponse proto.InternalMessageInfo

type MsgUpdatePerMessageBurnLimit struct {
	From                string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	PerMessageBurnLimit uint64 `protobuf:"varint,2,opt,name=perMessageBurnLimit,proto3" json:"perMessageBurnLimit,omitempty"`
}

func (m *MsgUpdatePerMessageBurnLimit) Reset()         { *m = MsgUpdatePerMessageBurnLimit{} }
func (m *MsgUpdatePerMessageBurnLimit) String() string { return proto.CompactTextString(m) }
func (*MsgUpdatePerMessageBurnLimit) ProtoMessage()    {}
func (*MsgUpdatePerMessageBurnLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{16}
}
func (m *MsgUpdatePerMessageBurnLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdatePerMessageBurnLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdatePerMessageBurnLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdatePerMessageBurnLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdatePerMessageBurnLimit.Merge(m, src)
}
func (m *MsgUpdatePerMessageBurnLimit) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdatePerMessageBurnLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdatePerMessageBurnLimit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdatePerMessageBurnLimit proto.InternalMessageInfo

func (m *MsgUpdatePerMessageBurnLimit) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgUpdatePerMessageBurnLimit) GetPerMessageBurnLimit() uint64 {
	if m != nil {
		return m.PerMessageBurnLimit
	}
	return 0
}

type MsgUpdatePerMessageBurnLimitResponse struct {
}

func (m *MsgUpdatePerMessageBurnLimitResponse) Reset()         { *m = MsgUpdatePerMessageBurnLimitResponse{} }
func (m *MsgUpdatePerMessageBurnLimitResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdatePerMessageBurnLimitResponse) ProtoMessage()    {}
func (*MsgUpdatePerMessageBurnLimitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{17}
}
func (m *MsgUpdatePerMessageBurnLimitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdatePerMessageBurnLimitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdatePerMessageBurnLimitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdatePerMessageBurnLimitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdatePerMessageBurnLimitResponse.Merge(m, src)
}
func (m *MsgUpdatePerMessageBurnLimitResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdatePerMessageBurnLimitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdatePerMessageBurnLimitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdatePerMessageBurnLimitResponse proto.InternalMessageInfo

type MsgDepositForBurn struct {
	From              string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Amount            uint32 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	DestinationDomain uint32 `protobuf:"varint,3,opt,name=destinationDomain,proto3" json:"destinationDomain,omitempty"`
	MintRecipient     []byte `protobuf:"bytes,4,opt,name=mintRecipient,proto3" json:"mintRecipient,omitempty"`
	BurnToken         string `protobuf:"bytes,5,opt,name=burnToken,proto3" json:"burnToken,omitempty"`
}

func (m *MsgDepositForBurn) Reset()         { *m = MsgDepositForBurn{} }
func (m *MsgDepositForBurn) String() string { return proto.CompactTextString(m) }
func (*MsgDepositForBurn) ProtoMessage()    {}
func (*MsgDepositForBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{18}
}
func (m *MsgDepositForBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositForBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositForBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositForBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositForBurn.Merge(m, src)
}
func (m *MsgDepositForBurn) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositForBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositForBurn.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositForBurn proto.InternalMessageInfo

func (m *MsgDepositForBurn) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgDepositForBurn) GetAmount() uint32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *MsgDepositForBurn) GetDestinationDomain() uint32 {
	if m != nil {
		return m.DestinationDomain
	}
	return 0
}

func (m *MsgDepositForBurn) GetMintRecipient() []byte {
	if m != nil {
		return m.MintRecipient
	}
	return nil
}

func (m *MsgDepositForBurn) GetBurnToken() string {
	if m != nil {
		return m.BurnToken
	}
	return ""
}

type MsgDepositForBurnResponse struct {
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *MsgDepositForBurnResponse) Reset()         { *m = MsgDepositForBurnResponse{} }
func (m *MsgDepositForBurnResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositForBurnResponse) ProtoMessage()    {}
func (*MsgDepositForBurnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{19}
}
func (m *MsgDepositForBurnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositForBurnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositForBurnResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositForBurnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositForBurnResponse.Merge(m, src)
}
func (m *MsgDepositForBurnResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositForBurnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositForBurnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositForBurnResponse proto.InternalMessageInfo

func (m *MsgDepositForBurnResponse) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type MsgDepositForBurnWithCaller struct {
	From              string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Amount            uint32 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	DestinationDomain uint32 `protobuf:"varint,3,opt,name=destinationDomain,proto3" json:"destinationDomain,omitempty"`
	MintRecipient     []byte `protobuf:"bytes,4,opt,name=mintRecipient,proto3" json:"mintRecipient,omitempty"`
	BurnToken         string `protobuf:"bytes,5,opt,name=burnToken,proto3" json:"burnToken,omitempty"`
	DestinationCaller []byte `protobuf:"bytes,6,opt,name=destinationCaller,proto3" json:"destinationCaller,omitempty"`
}

func (m *MsgDepositForBurnWithCaller) Reset()         { *m = MsgDepositForBurnWithCaller{} }
func (m *MsgDepositForBurnWithCaller) String() string { return proto.CompactTextString(m) }
func (*MsgDepositForBurnWithCaller) ProtoMessage()    {}
func (*MsgDepositForBurnWithCaller) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{20}
}
func (m *MsgDepositForBurnWithCaller) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositForBurnWithCaller) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositForBurnWithCaller.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositForBurnWithCaller) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositForBurnWithCaller.Merge(m, src)
}
func (m *MsgDepositForBurnWithCaller) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositForBurnWithCaller) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositForBurnWithCaller.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositForBurnWithCaller proto.InternalMessageInfo

func (m *MsgDepositForBurnWithCaller) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgDepositForBurnWithCaller) GetAmount() uint32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *MsgDepositForBurnWithCaller) GetDestinationDomain() uint32 {
	if m != nil {
		return m.DestinationDomain
	}
	return 0
}

func (m *MsgDepositForBurnWithCaller) GetMintRecipient() []byte {
	if m != nil {
		return m.MintRecipient
	}
	return nil
}

func (m *MsgDepositForBurnWithCaller) GetBurnToken() string {
	if m != nil {
		return m.BurnToken
	}
	return ""
}

func (m *MsgDepositForBurnWithCaller) GetDestinationCaller() []byte {
	if m != nil {
		return m.DestinationCaller
	}
	return nil
}

type MsgDepositForBurnWithCallerResponse struct {
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *MsgDepositForBurnWithCallerResponse) Reset()         { *m = MsgDepositForBurnWithCallerResponse{} }
func (m *MsgDepositForBurnWithCallerResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositForBurnWithCallerResponse) ProtoMessage()    {}
func (*MsgDepositForBurnWithCallerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{21}
}
func (m *MsgDepositForBurnWithCallerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositForBurnWithCallerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositForBurnWithCallerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositForBurnWithCallerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositForBurnWithCallerResponse.Merge(m, src)
}
func (m *MsgDepositForBurnWithCallerResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositForBurnWithCallerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositForBurnWithCallerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositForBurnWithCallerResponse proto.InternalMessageInfo

func (m *MsgDepositForBurnWithCallerResponse) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type MsgReplaceDepositForBurn struct {
	From                 string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	OriginalMessage      []byte `protobuf:"bytes,2,opt,name=originalMessage,proto3" json:"originalMessage,omitempty"`
	OriginalAttestation  []byte `protobuf:"bytes,3,opt,name=originalAttestation,proto3" json:"originalAttestation,omitempty"`
	NewDestinationCaller []byte `protobuf:"bytes,4,opt,name=newDestinationCaller,proto3" json:"newDestinationCaller,omitempty"`
	NewMintRecipient     []byte `protobuf:"bytes,5,opt,name=newMintRecipient,proto3" json:"newMintRecipient,omitempty"`
}

func (m *MsgReplaceDepositForBurn) Reset()         { *m = MsgReplaceDepositForBurn{} }
func (m *MsgReplaceDepositForBurn) String() string { return proto.CompactTextString(m) }
func (*MsgReplaceDepositForBurn) ProtoMessage()    {}
func (*MsgReplaceDepositForBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{22}
}
func (m *MsgReplaceDepositForBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReplaceDepositForBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReplaceDepositForBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReplaceDepositForBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReplaceDepositForBurn.Merge(m, src)
}
func (m *MsgReplaceDepositForBurn) XXX_Size() int {
	return m.Size()
}
func (m *MsgReplaceDepositForBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReplaceDepositForBurn.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReplaceDepositForBurn proto.InternalMessageInfo

func (m *MsgReplaceDepositForBurn) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgReplaceDepositForBurn) GetOriginalMessage() []byte {
	if m != nil {
		return m.OriginalMessage
	}
	return nil
}

func (m *MsgReplaceDepositForBurn) GetOriginalAttestation() []byte {
	if m != nil {
		return m.OriginalAttestation
	}
	return nil
}

func (m *MsgReplaceDepositForBurn) GetNewDestinationCaller() []byte {
	if m != nil {
		return m.NewDestinationCaller
	}
	return nil
}

func (m *MsgReplaceDepositForBurn) GetNewMintRecipient() []byte {
	if m != nil {
		return m.NewMintRecipient
	}
	return nil
}

type MsgReplaceDepositForBurnResponse struct {
}

func (m *MsgReplaceDepositForBurnResponse) Reset()         { *m = MsgReplaceDepositForBurnResponse{} }
func (m *MsgReplaceDepositForBurnResponse) String() string { return proto.CompactTextString(m) }
func (*MsgReplaceDepositForBurnResponse) ProtoMessage()    {}
func (*MsgReplaceDepositForBurnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{23}
}
func (m *MsgReplaceDepositForBurnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReplaceDepositForBurnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReplaceDepositForBurnResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReplaceDepositForBurnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReplaceDepositForBurnResponse.Merge(m, src)
}
func (m *MsgReplaceDepositForBurnResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgReplaceDepositForBurnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReplaceDepositForBurnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReplaceDepositForBurnResponse proto.InternalMessageInfo

type MsgReceiveMessage struct {
	From        string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Message     []byte `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Attestation []byte `protobuf:"bytes,3,opt,name=attestation,proto3" json:"attestation,omitempty"`
}

func (m *MsgReceiveMessage) Reset()         { *m = MsgReceiveMessage{} }
func (m *MsgReceiveMessage) String() string { return proto.CompactTextString(m) }
func (*MsgReceiveMessage) ProtoMessage()    {}
func (*MsgReceiveMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{24}
}
func (m *MsgReceiveMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReceiveMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReceiveMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReceiveMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReceiveMessage.Merge(m, src)
}
func (m *MsgReceiveMessage) XXX_Size() int {
	return m.Size()
}
func (m *MsgReceiveMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReceiveMessage.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReceiveMessage proto.InternalMessageInfo

func (m *MsgReceiveMessage) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgReceiveMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *MsgReceiveMessage) GetAttestation() []byte {
	if m != nil {
		return m.Attestation
	}
	return nil
}

type MsgReceiveMessageResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *MsgReceiveMessageResponse) Reset()         { *m = MsgReceiveMessageResponse{} }
func (m *MsgReceiveMessageResponse) String() string { return proto.CompactTextString(m) }
func (*MsgReceiveMessageResponse) ProtoMessage()    {}
func (*MsgReceiveMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{25}
}
func (m *MsgReceiveMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReceiveMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReceiveMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReceiveMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReceiveMessageResponse.Merge(m, src)
}
func (m *MsgReceiveMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgReceiveMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReceiveMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReceiveMessageResponse proto.InternalMessageInfo

func (m *MsgReceiveMessageResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type MsgSendMessage struct {
	From              string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	DestinationDomain uint32 `protobuf:"varint,2,opt,name=destinationDomain,proto3" json:"destinationDomain,omitempty"`
	Recipient         []byte `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
	MessageBody       []byte `protobuf:"bytes,4,opt,name=messageBody,proto3" json:"messageBody,omitempty"`
}

func (m *MsgSendMessage) Reset()         { *m = MsgSendMessage{} }
func (m *MsgSendMessage) String() string { return proto.CompactTextString(m) }
func (*MsgSendMessage) ProtoMessage()    {}
func (*MsgSendMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{26}
}
func (m *MsgSendMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendMessage.Merge(m, src)
}
func (m *MsgSendMessage) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendMessage.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendMessage proto.InternalMessageInfo

func (m *MsgSendMessage) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgSendMessage) GetDestinationDomain() uint32 {
	if m != nil {
		return m.DestinationDomain
	}
	return 0
}

func (m *MsgSendMessage) GetRecipient() []byte {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *MsgSendMessage) GetMessageBody() []byte {
	if m != nil {
		return m.MessageBody
	}
	return nil
}

type MsgSendMessageResponse struct {
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *MsgSendMessageResponse) Reset()         { *m = MsgSendMessageResponse{} }
func (m *MsgSendMessageResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSendMessageResponse) ProtoMessage()    {}
func (*MsgSendMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{27}
}
func (m *MsgSendMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendMessageResponse.Merge(m, src)
}
func (m *MsgSendMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendMessageResponse proto.InternalMessageInfo

func (m *MsgSendMessageResponse) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type MsgSendMessageWithCaller struct {
	From              string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	DestinationDomain uint32 `protobuf:"varint,2,opt,name=destinationDomain,proto3" json:"destinationDomain,omitempty"`
	Recipient         []byte `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
	MessageBody       []byte `protobuf:"bytes,4,opt,name=messageBody,proto3" json:"messageBody,omitempty"`
	DestinationCaller []byte `protobuf:"bytes,5,opt,name=destinationCaller,proto3" json:"destinationCaller,omitempty"`
}

func (m *MsgSendMessageWithCaller) Reset()         { *m = MsgSendMessageWithCaller{} }
func (m *MsgSendMessageWithCaller) String() string { return proto.CompactTextString(m) }
func (*MsgSendMessageWithCaller) ProtoMessage()    {}
func (*MsgSendMessageWithCaller) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{28}
}
func (m *MsgSendMessageWithCaller) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendMessageWithCaller) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendMessageWithCaller.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendMessageWithCaller) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendMessageWithCaller.Merge(m, src)
}
func (m *MsgSendMessageWithCaller) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendMessageWithCaller) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendMessageWithCaller.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendMessageWithCaller proto.InternalMessageInfo

func (m *MsgSendMessageWithCaller) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgSendMessageWithCaller) GetDestinationDomain() uint32 {
	if m != nil {
		return m.DestinationDomain
	}
	return 0
}

func (m *MsgSendMessageWithCaller) GetRecipient() []byte {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *MsgSendMessageWithCaller) GetMessageBody() []byte {
	if m != nil {
		return m.MessageBody
	}
	return nil
}

func (m *MsgSendMessageWithCaller) GetDestinationCaller() []byte {
	if m != nil {
		return m.DestinationCaller
	}
	return nil
}

type MsgSendMessageWithCallerResponse struct {
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *MsgSendMessageWithCallerResponse) Reset()         { *m = MsgSendMessageWithCallerResponse{} }
func (m *MsgSendMessageWithCallerResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSendMessageWithCallerResponse) ProtoMessage()    {}
func (*MsgSendMessageWithCallerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{29}
}
func (m *MsgSendMessageWithCallerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendMessageWithCallerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendMessageWithCallerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendMessageWithCallerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendMessageWithCallerResponse.Merge(m, src)
}
func (m *MsgSendMessageWithCallerResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendMessageWithCallerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendMessageWithCallerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendMessageWithCallerResponse proto.InternalMessageInfo

func (m *MsgSendMessageWithCallerResponse) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type MsgReplaceMessage struct {
	From                 string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	OriginalMessage      []byte `protobuf:"bytes,2,opt,name=originalMessage,proto3" json:"originalMessage,omitempty"`
	OriginalAttestation  []byte `protobuf:"bytes,3,opt,name=originalAttestation,proto3" json:"originalAttestation,omitempty"`
	NewMessageBody       []byte `protobuf:"bytes,4,opt,name=newMessageBody,proto3" json:"newMessageBody,omitempty"`
	NewDestinationCaller []byte `protobuf:"bytes,5,opt,name=newDestinationCaller,proto3" json:"newDestinationCaller,omitempty"`
}

func (m *MsgReplaceMessage) Reset()         { *m = MsgReplaceMessage{} }
func (m *MsgReplaceMessage) String() string { return proto.CompactTextString(m) }
func (*MsgReplaceMessage) ProtoMessage()    {}
func (*MsgReplaceMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{30}
}
func (m *MsgReplaceMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReplaceMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReplaceMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReplaceMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReplaceMessage.Merge(m, src)
}
func (m *MsgReplaceMessage) XXX_Size() int {
	return m.Size()
}
func (m *MsgReplaceMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReplaceMessage.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReplaceMessage proto.InternalMessageInfo

func (m *MsgReplaceMessage) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgReplaceMessage) GetOriginalMessage() []byte {
	if m != nil {
		return m.OriginalMessage
	}
	return nil
}

func (m *MsgReplaceMessage) GetOriginalAttestation() []byte {
	if m != nil {
		return m.OriginalAttestation
	}
	return nil
}

func (m *MsgReplaceMessage) GetNewMessageBody() []byte {
	if m != nil {
		return m.NewMessageBody
	}
	return nil
}

func (m *MsgReplaceMessage) GetNewDestinationCaller() []byte {
	if m != nil {
		return m.NewDestinationCaller
	}
	return nil
}

type MsgReplaceMessageResponse struct {
}

func (m *MsgReplaceMessageResponse) Reset()         { *m = MsgReplaceMessageResponse{} }
func (m *MsgReplaceMessageResponse) String() string { return proto.CompactTextString(m) }
func (*MsgReplaceMessageResponse) ProtoMessage()    {}
func (*MsgReplaceMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{31}
}
func (m *MsgReplaceMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReplaceMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReplaceMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReplaceMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReplaceMessageResponse.Merge(m, src)
}
func (m *MsgReplaceMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgReplaceMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReplaceMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReplaceMessageResponse proto.InternalMessageInfo

type MsgUpdateSignatureThreshold struct {
	From   string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Amount uint32 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *MsgUpdateSignatureThreshold) Reset()         { *m = MsgUpdateSignatureThreshold{} }
func (m *MsgUpdateSignatureThreshold) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateSignatureThreshold) ProtoMessage()    {}
func (*MsgUpdateSignatureThreshold) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{32}
}
func (m *MsgUpdateSignatureThreshold) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateSignatureThreshold) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateSignatureThreshold.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateSignatureThreshold) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateSignatureThreshold.Merge(m, src)
}
func (m *MsgUpdateSignatureThreshold) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateSignatureThreshold) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateSignatureThreshold.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateSignatureThreshold proto.InternalMessageInfo

func (m *MsgUpdateSignatureThreshold) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgUpdateSignatureThreshold) GetAmount() uint32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type MsgUpdateSignatureThresholdResponse struct {
}

func (m *MsgUpdateSignatureThresholdResponse) Reset()         { *m = MsgUpdateSignatureThresholdResponse{} }
func (m *MsgUpdateSignatureThresholdResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateSignatureThresholdResponse) ProtoMessage()    {}
func (*MsgUpdateSignatureThresholdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{33}
}
func (m *MsgUpdateSignatureThresholdResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateSignatureThresholdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateSignatureThresholdResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateSignatureThresholdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateSignatureThresholdResponse.Merge(m, src)
}
func (m *MsgUpdateSignatureThresholdResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateSignatureThresholdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateSignatureThresholdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateSignatureThresholdResponse proto.InternalMessageInfo

type MsgUpdateMinterAllowance struct {
	From   string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Denom  string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Amount uint64 `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *MsgUpdateMinterAllowance) Reset()         { *m = MsgUpdateMinterAllowance{} }
func (m *MsgUpdateMinterAllowance) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateMinterAllowance) ProtoMessage()    {}
func (*MsgUpdateMinterAllowance) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{34}
}
func (m *MsgUpdateMinterAllowance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateMinterAllowance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateMinterAllowance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateMinterAllowance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateMinterAllowance.Merge(m, src)
}
func (m *MsgUpdateMinterAllowance) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateMinterAllowance) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateMinterAllowance.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateMinterAllowance proto.InternalMessageInfo

func (m *MsgUpdateMinterAllowance) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgUpdateMinterAllowance) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateMinterAllowance) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type MsgUpdateMinterAllowanceResponse struct {
}

func (m *MsgUpdateMinterAllowanceResponse) Reset()         { *m = MsgUpdateMinterAllowanceResponse{} }
func (m *MsgUpdateMinterAllowanceResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateMinterAllowanceResponse) ProtoMessage()    {}
func (*MsgUpdateMinterAllowanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{35}
}
func (m *MsgUpdateMinterAllowanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateMinterAllowanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateMinterAllowanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateMinterAllowanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateMinterAllowanceResponse.Merge(m, src)
}
func (m *MsgUpdateMinterAllowanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateMinterAllowanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateMinterAllowanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateMinterAllowanceResponse proto.InternalMessageInfo

type MsgLinkTokenPair struct {
	From         string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	RemoteDomain uint32 `protobuf:"varint,2,opt,name=remoteDomain,proto3" json:"remoteDomain,omitempty"`
	RemoteToken  string `protobuf:"bytes,3,opt,name=remoteToken,proto3" json:"remoteToken,omitempty"`
	LocalToken   string `protobuf:"bytes,4,opt,name=localToken,proto3" json:"localToken,omitempty"`
}

func (m *MsgLinkTokenPair) Reset()         { *m = MsgLinkTokenPair{} }
func (m *MsgLinkTokenPair) String() string { return proto.CompactTextString(m) }
func (*MsgLinkTokenPair) ProtoMessage()    {}
func (*MsgLinkTokenPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{36}
}
func (m *MsgLinkTokenPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLinkTokenPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLinkTokenPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLinkTokenPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLinkTokenPair.Merge(m, src)
}
func (m *MsgLinkTokenPair) XXX_Size() int {
	return m.Size()
}
func (m *MsgLinkTokenPair) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLinkTokenPair.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLinkTokenPair proto.InternalMessageInfo

func (m *MsgLinkTokenPair) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgLinkTokenPair) GetRemoteDomain() uint32 {
	if m != nil {
		return m.RemoteDomain
	}
	return 0
}

func (m *MsgLinkTokenPair) GetRemoteToken() string {
	if m != nil {
		return m.RemoteToken
	}
	return ""
}

func (m *MsgLinkTokenPair) GetLocalToken() string {
	if m != nil {
		return m.LocalToken
	}
	return ""
}

type MsgLinkTokenPairResponse struct {
}

func (m *MsgLinkTokenPairResponse) Reset()         { *m = MsgLinkTokenPairResponse{} }
func (m *MsgLinkTokenPairResponse) String() string { return proto.CompactTextString(m) }
func (*MsgLinkTokenPairResponse) ProtoMessage()    {}
func (*MsgLinkTokenPairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{37}
}
func (m *MsgLinkTokenPairResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLinkTokenPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLinkTokenPairResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLinkTokenPairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLinkTokenPairResponse.Merge(m, src)
}
func (m *MsgLinkTokenPairResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgLinkTokenPairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLinkTokenPairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLinkTokenPairResponse proto.InternalMessageInfo

type MsgUnlinkTokenPair struct {
	From         string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	RemoteDomain uint32 `protobuf:"varint,2,opt,name=remoteDomain,proto3" json:"remoteDomain,omitempty"`
	RemoteToken  string `protobuf:"bytes,3,opt,name=remoteToken,proto3" json:"remoteToken,omitempty"`
	LocalToken   string `protobuf:"bytes,4,opt,name=localToken,proto3" json:"localToken,omitempty"`
}

func (m *MsgUnlinkTokenPair) Reset()         { *m = MsgUnlinkTokenPair{} }
func (m *MsgUnlinkTokenPair) String() string { return proto.CompactTextString(m) }
func (*MsgUnlinkTokenPair) ProtoMessage()    {}
func (*MsgUnlinkTokenPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{38}
}
func (m *MsgUnlinkTokenPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUnlinkTokenPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUnlinkTokenPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUnlinkTokenPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUnlinkTokenPair.Merge(m, src)
}
func (m *MsgUnlinkTokenPair) XXX_Size() int {
	return m.Size()
}
func (m *MsgUnlinkTokenPair) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUnlinkTokenPair.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUnlinkTokenPair proto.InternalMessageInfo

func (m *MsgUnlinkTokenPair) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgUnlinkTokenPair) GetRemoteDomain() uint32 {
	if m != nil {
		return m.RemoteDomain
	}
	return 0
}

func (m *MsgUnlinkTokenPair) GetRemoteToken() string {
	if m != nil {
		return m.RemoteToken
	}
	return ""
}

func (m *MsgUnlinkTokenPair) GetLocalToken() string {
	if m != nil {
		return m.LocalToken
	}
	return ""
}

type MsgUnlinkTokenPairResponse struct {
}

func (m *MsgUnlinkTokenPairResponse) Reset()         { *m = MsgUnlinkTokenPairResponse{} }
func (m *MsgUnlinkTokenPairResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUnlinkTokenPairResponse) ProtoMessage()    {}
func (*MsgUnlinkTokenPairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e1e06b1ff3c499c, []int{39}
}
func (m *MsgUnlinkTokenPairResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUnlinkTokenPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUnlinkTokenPairResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUnlinkTokenPairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUnlinkTokenPairResponse.Merge(m, src)
}
func (m *MsgUnlinkTokenPairResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUnlinkTokenPairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUnlinkTokenPairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUnlinkTokenPairResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgUpdateAuthority)(nil), "noble.cctp.MsgUpdateAuthority")
	proto.RegisterType((*MsgUpdateAuthorityResponse)(nil), "noble.cctp.MsgUpdateAuthorityResponse")
	proto.RegisterType((*MsgAddPublicKey)(nil), "noble.cctp.MsgAddPublicKey")
	proto.RegisterType((*MsgAddPublicKeyResponse)(nil), "noble.cctp.MsgAddPublicKeyResponse")
	proto.RegisterType((*MsgRemovePublicKey)(nil), "noble.cctp.MsgRemovePublicKey")
	proto.RegisterType((*MsgRemovePublicKeyResponse)(nil), "noble.cctp.MsgRemovePublicKeyResponse")
	proto.RegisterType((*MsgPauseBurningAndMinting)(nil), "noble.cctp.MsgPauseBurningAndMinting")
	proto.RegisterType((*MsgPauseBurningAndMintingResponse)(nil), "noble.cctp.MsgPauseBurningAndMintingResponse")
	proto.RegisterType((*MsgUnpauseBurningAndMinting)(nil), "noble.cctp.MsgUnpauseBurningAndMinting")
	proto.RegisterType((*MsgUnpauseBurningAndMintingResponse)(nil), "noble.cctp.MsgUnpauseBurningAndMintingResponse")
	proto.RegisterType((*MsgPauseSendingAndReceivingMessages)(nil), "noble.cctp.MsgPauseSendingAndReceivingMessages")
	proto.RegisterType((*MsgPauseSendingAndReceivingMessagesResponse)(nil), "noble.cctp.MsgPauseSendingAndReceivingMessagesResponse")
	proto.RegisterType((*MsgUnpauseSendingAndReceivingMessages)(nil), "noble.cctp.MsgUnpauseSendingAndReceivingMessages")
	proto.RegisterType((*MsgUnpauseSendingAndReceivingMessagesResponse)(nil), "noble.cctp.MsgUnpauseSendingAndReceivingMessagesResponse")
	proto.RegisterType((*MsgUpdateMaxMessageBodySize)(nil), "noble.cctp.MsgUpdateMaxMessageBodySize")
	proto.RegisterType((*MsgUpdateMaxMessageBodySizeResponse)(nil), "noble.cctp.MsgUpdateMaxMessageBodySizeResponse")
	proto.RegisterType((*MsgUpdatePerMessageBurnLimit)(nil), "noble.cctp.MsgUpdatePerMessageBurnLimit")
	proto.RegisterType((*MsgUpdatePerMessageBurnLimitResponse)(nil), "noble.cctp.MsgUpdatePerMessageBurnLimitResponse")
	proto.RegisterType((*MsgDepositForBurn)(nil), "noble.cctp.MsgDepositForBurn")
	proto.RegisterType((*MsgDepositForBurnResponse)(nil), "noble.cctp.MsgDepositForBurnResponse")
	proto.RegisterType((*MsgDepositForBurnWithCaller)(nil), "noble.cctp.MsgDepositForBurnWithCaller")
	proto.RegisterType((*MsgDepositForBurnWithCallerResponse)(nil), "noble.cctp.MsgDepositForBurnWithCallerResponse")
	proto.RegisterType((*MsgReplaceDepositForBurn)(nil), "noble.cctp.MsgReplaceDepositForBurn")
	proto.RegisterType((*MsgReplaceDepositForBurnResponse)(nil), "noble.cctp.MsgReplaceDepositForBurnResponse")
	proto.RegisterType((*MsgReceiveMessage)(nil), "noble.cctp.MsgReceiveMessage")
	proto.RegisterType((*MsgReceiveMessageResponse)(nil), "noble.cctp.MsgReceiveMessageResponse")
	proto.RegisterType((*MsgSendMessage)(nil), "noble.cctp.MsgSendMessage")
	proto.RegisterType((*MsgSendMessageResponse)(nil), "noble.cctp.MsgSendMessageResponse")
	proto.RegisterType((*MsgSendMessageWithCaller)(nil), "noble.cctp.MsgSendMessageWithCaller")
	proto.RegisterType((*MsgSendMessageWithCallerResponse)(nil), "noble.cctp.MsgSendMessageWithCallerResponse")
	proto.RegisterType((*MsgReplaceMessage)(nil), "noble.cctp.MsgReplaceMessage")
	proto.RegisterType((*MsgReplaceMessageResponse)(nil), "noble.cctp.MsgReplaceMessageResponse")
	proto.RegisterType((*MsgUpdateSignatureThreshold)(nil), "noble.cctp.MsgUpdateSignatureThreshold")
	proto.RegisterType((*MsgUpdateSignatureThresholdResponse)(nil), "noble.cctp.MsgUpdateSignatureThresholdResponse")
	proto.RegisterType((*MsgUpdateMinterAllowance)(nil), "noble.cctp.MsgUpdateMinterAllowance")
	proto.RegisterType((*MsgUpdateMinterAllowanceResponse)(nil), "noble.cctp.MsgUpdateMinterAllowanceResponse")
	proto.RegisterType((*MsgLinkTokenPair)(nil), "noble.cctp.MsgLinkTokenPair")
	proto.RegisterType((*MsgLinkTokenPairResponse)(nil), "noble.cctp.MsgLinkTokenPairResponse")
	proto.RegisterType((*MsgUnlinkTokenPair)(nil), "noble.cctp.MsgUnlinkTokenPair")
	proto.RegisterType((*MsgUnlinkTokenPairResponse)(nil), "noble.cctp.MsgUnlinkTokenPairResponse")
}

func init() { proto.RegisterFile("cctp/tx.proto", fileDescriptor_9e1e06b1ff3c499c) }

var fileDescriptor_9e1e06b1ff3c499c = []byte{
	// 1294 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xdd, 0x6e, 0x1b, 0xc5,
	0x17, 0xef, 0x36, 0x76, 0xfb, 0xcf, 0x69, 0xbe, 0xba, 0xff, 0x34, 0x38, 0x9b, 0xc4, 0x0a, 0x1b,
	0xe7, 0x43, 0x90, 0xd8, 0x4d, 0x10, 0x82, 0xaa, 0x57, 0x09, 0x01, 0x84, 0xc8, 0x4a, 0x91, 0x53,
	0x40, 0x45, 0x48, 0xd5, 0x66, 0x3d, 0x6c, 0x46, 0x59, 0xcf, 0xac, 0x76, 0xc6, 0x71, 0xd2, 0x67,
	0xa8, 0x10, 0xea, 0x9b, 0xf0, 0x06, 0x5c, 0x22, 0xae, 0x7a, 0xc9, 0x1d, 0x28, 0xb9, 0x82, 0xa7,
	0x40, 0x9e, 0xb5, 0xc7, 0xbb, 0x3b, 0xb3, 0x6b, 0x47, 0x08, 0xd4, 0x3b, 0xcf, 0x39, 0xbf, 0xf3,
	0x39, 0xe7, 0x9c, 0xd9, 0x63, 0x98, 0xf6, 0x3c, 0x1e, 0x36, 0xf8, 0x65, 0x3d, 0x8c, 0x28, 0xa7,
	0x26, 0x10, 0x7a, 0x1a, 0xa0, 0x7a, 0x8f, 0x68, 0xcd, 0xfb, 0xd4, 0xa7, 0x82, 0xdc, 0xe8, 0xfd,
	0x8a, 0x11, 0xb6, 0x03, 0xa6, 0xc3, 0xfc, 0xaf, 0xc2, 0x96, 0xcb, 0xd1, 0x7e, 0x87, 0x9f, 0xd1,
	0x08, 0xf3, 0x2b, 0xd3, 0x84, 0xd2, 0xf7, 0x11, 0x6d, 0x57, 0x8c, 0x55, 0x63, 0x6b, 0xb2, 0x29,
	0x7e, 0x9b, 0x6b, 0x30, 0x4d, 0x50, 0xf7, 0x85, 0x3b, 0x00, 0x55, 0xee, 0x0a, 0xe6, 0x14, 0x41,
	0x5d, 0x29, 0x68, 0x2f, 0x83, 0xa5, 0xaa, 0x6b, 0x22, 0x16, 0x52, 0xc2, 0x90, 0x7d, 0x08, 0xb3,
	0x0e, 0xf3, 0xf7, 0x5b, 0xad, 0xe3, 0xce, 0x69, 0x80, 0xbd, 0x2f, 0x91, 0xde, 0xd2, 0x0a, 0x40,
	0x28, 0x00, 0x2f, 0xce, 0x51, 0x6c, 0x66, 0xaa, 0x39, 0x19, 0x0e, 0x44, 0xec, 0x45, 0x78, 0x27,
	0xa3, 0x45, 0x1a, 0xf8, 0x5c, 0x44, 0xd3, 0x44, 0x6d, 0x7a, 0x81, 0xfe, 0x91, 0x8d, 0x38, 0x8e,
	0x8c, 0x22, 0x69, 0xa6, 0x01, 0x8b, 0x0e, 0xf3, 0x8f, 0xdd, 0x0e, 0x43, 0x07, 0x9d, 0x88, 0x60,
	0xe2, 0xef, 0x93, 0x96, 0x83, 0x09, 0xc7, 0xc4, 0xd7, 0x59, 0xb3, 0xd7, 0xe0, 0xdd, 0x5c, 0x01,
	0xa9, 0x75, 0x17, 0x96, 0x7a, 0xb9, 0x23, 0xe1, 0xf8, 0x7a, 0xd7, 0x61, 0xad, 0x40, 0x44, 0x6a,
	0x7e, 0x22, 0x60, 0xc2, 0xfc, 0x09, 0x22, 0xad, 0x18, 0xd4, 0x44, 0x1e, 0xc2, 0x17, 0x98, 0xf8,
	0x0e, 0x62, 0xcc, 0xf5, 0x11, 0xd3, 0x5a, 0xd8, 0x81, 0xf7, 0xc7, 0x10, 0x95, 0x96, 0x9e, 0xc2,
	0xfa, 0xd0, 0xa1, 0xdb, 0xda, 0x6a, 0xc0, 0xce, 0x58, 0xc2, 0xd2, 0xda, 0xa7, 0x71, 0xc6, 0x44,
	0xb5, 0x39, 0xee, 0x65, 0x9f, 0x7f, 0x40, 0x5b, 0x57, 0x27, 0xf8, 0x25, 0xd2, 0xde, 0xbb, 0x09,
	0x25, 0x86, 0x5f, 0x22, 0x71, 0xe3, 0xd3, 0x4d, 0xf1, 0x7b, 0x90, 0xc5, 0x1c, 0x35, 0xd2, 0x5a,
	0x0b, 0x96, 0x25, 0xec, 0x18, 0x45, 0x03, 0x58, 0x27, 0x22, 0x47, 0xb8, 0x8d, 0xb9, 0xd6, 0xdc,
	0x63, 0xf8, 0x7f, 0xa8, 0x42, 0x85, 0xf5, 0x52, 0x53, 0xc7, 0xb2, 0x37, 0xa0, 0x56, 0x64, 0x45,
	0x7a, 0xf3, 0x93, 0x01, 0x0f, 0x1d, 0xe6, 0x1f, 0xa2, 0x90, 0x32, 0xcc, 0x3f, 0xa3, 0x51, 0x0f,
	0xa2, 0xf5, 0x61, 0x01, 0xee, 0xb9, 0x6d, 0xda, 0x21, 0xbc, 0x1f, 0x74, 0xff, 0x64, 0x6e, 0xc3,
	0xc3, 0x16, 0x62, 0x1c, 0x13, 0x97, 0x63, 0x4a, 0x0e, 0x69, 0xdb, 0xc5, 0xa4, 0x32, 0x21, 0x20,
	0x2a, 0xc3, 0xac, 0xc1, 0x74, 0x1b, 0x13, 0xde, 0x44, 0x1e, 0x0e, 0x31, 0x22, 0xbc, 0x52, 0x12,
	0x3d, 0x93, 0x26, 0x9a, 0xcb, 0x30, 0x79, 0xda, 0x89, 0xc8, 0x33, 0x7a, 0x8e, 0x48, 0xa5, 0x2c,
	0x9c, 0x18, 0x12, 0xec, 0x5d, 0xd1, 0x37, 0x69, 0x97, 0x07, 0x01, 0x99, 0xf3, 0x50, 0x26, 0x94,
	0x78, 0x48, 0xf8, 0x5e, 0x6a, 0xc6, 0x07, 0xfb, 0x4f, 0x43, 0xdc, 0x71, 0x5a, 0xe6, 0x1b, 0xcc,
	0xcf, 0x3e, 0x71, 0x83, 0x00, 0x45, 0x6f, 0x77, 0xc0, 0x19, 0x8b, 0xb1, 0xcb, 0x95, 0x7b, 0x42,
	0x8f, 0xca, 0xb0, 0x9f, 0x8a, 0x3a, 0xcc, 0x0b, 0x75, 0x44, 0xa2, 0xfe, 0x32, 0xa0, 0x22, 0x46,
	0x56, 0x18, 0xb8, 0x1e, 0x1a, 0xa3, 0x2c, 0xb6, 0x60, 0x96, 0x46, 0xd8, 0xc7, 0xc4, 0x0d, 0xfa,
	0x45, 0xd6, 0x1f, 0x83, 0x59, 0x72, 0xaf, 0x88, 0x07, 0xa4, 0x7d, 0xce, 0x11, 0xe3, 0xc2, 0x69,
	0x91, 0xb9, 0xa9, 0xa6, 0x8e, 0x65, 0xee, 0xc1, 0x3c, 0x41, 0xdd, 0x43, 0x25, 0xf4, 0x38, 0x85,
	0x5a, 0x9e, 0xf9, 0x1e, 0xcc, 0x11, 0xd4, 0x75, 0x52, 0x29, 0x2f, 0x0b, 0xbc, 0x42, 0xb7, 0x6d,
	0x58, 0xcd, 0x8b, 0x55, 0x36, 0x88, 0x27, 0xfa, 0x23, 0x1e, 0x1e, 0x68, 0x10, 0x8a, 0x2e, 0x11,
	0x15, 0xb8, 0xdf, 0x4e, 0x25, 0x60, 0x70, 0x34, 0x57, 0xe1, 0x81, 0xab, 0x04, 0x9c, 0x24, 0xd9,
	0x1f, 0x8a, 0x8a, 0x4e, 0x1b, 0x91, 0x17, 0x55, 0x81, 0xfb, 0xac, 0xe3, 0x79, 0x88, 0x31, 0x61,
	0xef, 0x7f, 0xcd, 0xc1, 0xd1, 0x7e, 0x6d, 0xc0, 0x8c, 0xc3, 0xfc, 0xde, 0x8c, 0x2b, 0xf2, 0x4c,
	0x5b, 0xb0, 0x77, 0xf3, 0x0a, 0x76, 0x19, 0x26, 0x23, 0x99, 0xb9, 0xd8, 0xd7, 0x21, 0xa1, 0x17,
	0x4b, 0x7b, 0x38, 0xd8, 0xfa, 0x37, 0x91, 0x24, 0xd9, 0x75, 0x58, 0x48, 0xfb, 0x34, 0xa2, 0xe2,
	0x7e, 0x8d, 0x2b, 0x2e, 0x21, 0x30, 0xa2, 0x2f, 0xff, 0xd3, 0x70, 0xf4, 0xbd, 0x57, 0xce, 0xeb,
	0xbd, 0x8f, 0x45, 0x45, 0x69, 0x63, 0x19, 0x91, 0x86, 0xdf, 0x8d, 0x7e, 0xa1, 0x89, 0x62, 0x2c,
	0xba, 0xce, 0x7f, 0xb3, 0xe3, 0x36, 0x60, 0xa6, 0xd7, 0x25, 0x4a, 0x4a, 0x32, 0xd4, 0xdc, 0xce,
	0x2c, 0xe7, 0x77, 0xa6, 0xbd, 0xd4, 0x2f, 0xf2, 0x64, 0x80, 0xb2, 0xcd, 0xbe, 0x48, 0xbc, 0xc1,
	0x27, 0xd8, 0x27, 0x2e, 0xef, 0x44, 0xe8, 0xd9, 0x59, 0x84, 0xd8, 0x19, 0x0d, 0x5a, 0xb7, 0x99,
	0xcf, 0xa9, 0x77, 0x58, 0x55, 0x25, 0x2d, 0x7e, 0x27, 0xca, 0xae, 0xff, 0x5c, 0x63, 0xc2, 0x51,
	0xb4, 0x1f, 0x04, 0xb4, 0xeb, 0x12, 0x4f, 0x9f, 0xf6, 0x79, 0x28, 0xb7, 0x10, 0xa1, 0xed, 0xfe,
	0x07, 0x6b, 0x7c, 0x48, 0x38, 0x31, 0x21, 0x6e, 0x73, 0xe0, 0x44, 0x3c, 0x5a, 0xb4, 0xda, 0xa5,
	0x07, 0xaf, 0x0c, 0x98, 0x73, 0x98, 0x7f, 0x84, 0xc9, 0xb9, 0x98, 0xf3, 0xc7, 0x2e, 0xd6, 0x57,
	0xbc, 0x0d, 0x53, 0x11, 0x6a, 0x53, 0x8e, 0x52, 0xc5, 0x9e, 0xa2, 0xf5, 0x2a, 0x39, 0x3e, 0xc7,
	0x6f, 0xc8, 0x84, 0x10, 0x4f, 0x92, 0xcc, 0x2a, 0x40, 0x40, 0x3d, 0x37, 0x88, 0x01, 0x25, 0x01,
	0x48, 0x50, 0x6c, 0x4b, 0x24, 0x24, 0xe5, 0x8d, 0x74, 0xf5, 0x07, 0x23, 0xfe, 0xc0, 0x27, 0xc1,
	0x5b, 0xe2, 0x6c, 0x7f, 0x43, 0x48, 0xfb, 0x33, 0x70, 0x77, 0xef, 0xe7, 0x39, 0x98, 0x70, 0x98,
	0x6f, 0x3e, 0x87, 0xd9, 0xec, 0x4e, 0x52, 0xad, 0x0f, 0x97, 0x99, 0xba, 0xba, 0x64, 0x58, 0x1b,
	0xc5, 0x7c, 0xd9, 0xc5, 0xc7, 0x30, 0x95, 0xda, 0x40, 0x96, 0x32, 0x72, 0x49, 0xa6, 0xb5, 0x56,
	0xc0, 0x94, 0x1a, 0x9f, 0xc3, 0x6c, 0x76, 0xe5, 0xc8, 0x3a, 0x9b, 0xe1, 0x2b, 0xce, 0xe6, 0x6c,
	0x1a, 0x26, 0x81, 0x85, 0x9c, 0x35, 0x63, 0x3d, 0xa3, 0x41, 0x0f, 0xb3, 0x76, 0xc6, 0x82, 0x49,
	0x7b, 0x1c, 0x2a, 0xb9, 0x0b, 0xc8, 0x66, 0x36, 0xc1, 0x39, 0x40, 0xab, 0x31, 0x26, 0x50, 0x5a,
	0x7d, 0x65, 0xc0, 0xea, 0xc8, 0xed, 0xa4, 0xa1, 0x8b, 0xa4, 0x40, 0xc0, 0xfa, 0xe8, 0x96, 0x02,
	0xd2, 0x9d, 0xd7, 0x06, 0xd8, 0x63, 0xac, 0x30, 0xbb, 0xfa, 0x30, 0x8b, 0x5c, 0x7a, 0x72, 0x6b,
	0x91, 0xd4, 0xcd, 0xe4, 0x2d, 0x3a, 0x9b, 0xda, 0xd2, 0x57, 0x81, 0xea, 0xcd, 0x8c, 0xd8, 0x79,
	0xcc, 0x2e, 0x2c, 0xe6, 0x2f, 0x3c, 0x5b, 0x5a, 0x6d, 0x1a, 0xa4, 0xf5, 0x78, 0x5c, 0xa4, 0x1a,
	0xae, 0xe6, 0x4d, 0xd1, 0x87, 0xab, 0x02, 0x73, 0xc2, 0xcd, 0x7f, 0x5a, 0xcc, 0x73, 0x78, 0xa4,
	0x7f, 0x57, 0x6a, 0xfa, 0xc4, 0xa5, 0x51, 0xd6, 0xf6, 0x38, 0x28, 0x69, 0xec, 0x04, 0xa6, 0xd3,
	0x2f, 0xc8, 0x72, 0x46, 0x3c, 0xc5, 0xb5, 0x6a, 0x45, 0xdc, 0xe4, 0x2c, 0xca, 0xce, 0x7a, 0x65,
	0x70, 0xa6, 0xf9, 0xea, 0xe0, 0xd4, 0xcf, 0x66, 0xf3, 0x6b, 0x98, 0xc9, 0xac, 0x15, 0x2b, 0x19,
	0xc9, 0x34, 0xdb, 0x5a, 0x2f, 0x64, 0x27, 0xaf, 0x3a, 0x77, 0xbd, 0xdb, 0x2c, 0x54, 0x31, 0x04,
	0x2a, 0x57, 0x3d, 0x72, 0x8b, 0x3a, 0x87, 0x47, 0xfa, 0x5d, 0xa9, 0xa6, 0x8c, 0x66, 0x0d, 0x4a,
	0xb9, 0xea, 0xc2, 0x5d, 0xa4, 0x97, 0xba, 0xcc, 0x22, 0xb2, 0xa2, 0xc8, 0x27, 0xd9, 0x4a, 0xea,
	0x72, 0x36, 0x0c, 0x07, 0x1e, 0x24, 0x77, 0x08, 0x2b, 0x23, 0x95, 0xe0, 0x59, 0x76, 0x3e, 0x2f,
	0x99, 0x13, 0xfd, 0xd7, 0x7c, 0x2d, 0x5f, 0x38, 0x71, 0x07, 0xdb, 0xe3, 0xa0, 0xd2, 0x39, 0x49,
	0x7d, 0x33, 0xaf, 0xe8, 0x73, 0x9a, 0x9f, 0x13, 0xdd, 0x07, 0xe9, 0xc1, 0xd1, 0x2f, 0xd7, 0x55,
	0xe3, 0xcd, 0x75, 0xd5, 0xf8, 0xe3, 0xba, 0x6a, 0xfc, 0x78, 0x53, 0xbd, 0xf3, 0xe6, 0xa6, 0x7a,
	0xe7, 0xb7, 0x9b, 0xea, 0x9d, 0x6f, 0xf7, 0x7c, 0xcc, 0xcf, 0x3a, 0xa7, 0x75, 0x8f, 0xb6, 0x1b,
	0x8c, 0x47, 0x2e, 0xf1, 0x51, 0x40, 0x2f, 0xd0, 0xce, 0x05, 0x22, 0xbd, 0x71, 0xc0, 0x1a, 0x42,
	0x7f, 0xe3, 0xb2, 0x11, 0xff, 0x89, 0x7a, 0x15, 0x22, 0x76, 0x7a, 0x4f, 0xfc, 0x4d, 0xfa, 0xc1,
	0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xab, 0xee, 0x45, 0xc2, 0x59, 0x15, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	UpdateAuthority(ctx context.Context, in *MsgUpdateAuthority, opts ...grpc.CallOption) (*MsgUpdateAuthorityResponse, error)
	AddPublicKey(ctx context.Context, in *MsgAddPublicKey, opts ...grpc.CallOption) (*MsgAddPublicKeyResponse, error)
	RemovePublicKey(ctx context.Context, in *MsgRemovePublicKey, opts ...grpc.CallOption) (*MsgRemovePublicKeyResponse, error)
	PauseBurningAndMinting(ctx context.Context, in *MsgPauseBurningAndMinting, opts ...grpc.CallOption) (*MsgPauseBurningAndMintingResponse, error)
	UnpauseBurningAndMinting(ctx context.Context, in *MsgUnpauseBurningAndMinting, opts ...grpc.CallOption) (*MsgUnpauseBurningAndMintingResponse, error)
	PauseSendingAndReceivingMessages(ctx context.Context, in *MsgPauseSendingAndReceivingMessages, opts ...grpc.CallOption) (*MsgPauseSendingAndReceivingMessagesResponse, error)
	UnpauseSendingAndReceivingMessages(ctx context.Context, in *MsgUnpauseSendingAndReceivingMessages, opts ...grpc.CallOption) (*MsgUnpauseSendingAndReceivingMessagesResponse, error)
	UpdateMaxMessageBodySize(ctx context.Context, in *MsgUpdateMaxMessageBodySize, opts ...grpc.CallOption) (*MsgUpdateMaxMessageBodySizeResponse, error)
	UpdatePerMessageBurnLimit(ctx context.Context, in *MsgUpdatePerMessageBurnLimit, opts ...grpc.CallOption) (*MsgUpdatePerMessageBurnLimitResponse, error)
	UpdateSignatureThreshold(ctx context.Context, in *MsgUpdateSignatureThreshold, opts ...grpc.CallOption) (*MsgUpdateSignatureThresholdResponse, error)
	UpdateMinterAllowance(ctx context.Context, in *MsgUpdateMinterAllowance, opts ...grpc.CallOption) (*MsgUpdateMinterAllowanceResponse, error)
	LinkTokenPair(ctx context.Context, in *MsgLinkTokenPair, opts ...grpc.CallOption) (*MsgLinkTokenPairResponse, error)
	UnlinkTokenPair(ctx context.Context, in *MsgUnlinkTokenPair, opts ...grpc.CallOption) (*MsgUnlinkTokenPairResponse, error)
	DepositForBurn(ctx context.Context, in *MsgDepositForBurn, opts ...grpc.CallOption) (*MsgDepositForBurnResponse, error)
	DepositForBurnWithCaller(ctx context.Context, in *MsgDepositForBurnWithCaller, opts ...grpc.CallOption) (*MsgDepositForBurnWithCallerResponse, error)
	ReplaceDepositForBurn(ctx context.Context, in *MsgReplaceDepositForBurn, opts ...grpc.CallOption) (*MsgReplaceDepositForBurnResponse, error)
	ReceiveMessage(ctx context.Context, in *MsgReceiveMessage, opts ...grpc.CallOption) (*MsgReceiveMessageResponse, error)
	SendMessage(ctx context.Context, in *MsgSendMessage, opts ...grpc.CallOption) (*MsgSendMessageResponse, error)
	SendMessageWithCaller(ctx context.Context, in *MsgSendMessageWithCaller, opts ...grpc.CallOption) (*MsgSendMessageWithCallerResponse, error)
	ReplaceMessage(ctx context.Context, in *MsgReplaceMessage, opts ...grpc.CallOption) (*MsgReplaceMessageResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateAuthority(ctx context.Context, in *MsgUpdateAuthority, opts ...grpc.CallOption) (*MsgUpdateAuthorityResponse, error) {
	out := new(MsgUpdateAuthorityResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/UpdateAuthority", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddPublicKey(ctx context.Context, in *MsgAddPublicKey, opts ...grpc.CallOption) (*MsgAddPublicKeyResponse, error) {
	out := new(MsgAddPublicKeyResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/AddPublicKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemovePublicKey(ctx context.Context, in *MsgRemovePublicKey, opts ...grpc.CallOption) (*MsgRemovePublicKeyResponse, error) {
	out := new(MsgRemovePublicKeyResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/RemovePublicKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PauseBurningAndMinting(ctx context.Context, in *MsgPauseBurningAndMinting, opts ...grpc.CallOption) (*MsgPauseBurningAndMintingResponse, error) {
	out := new(MsgPauseBurningAndMintingResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/PauseBurningAndMinting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UnpauseBurningAndMinting(ctx context.Context, in *MsgUnpauseBurningAndMinting, opts ...grpc.CallOption) (*MsgUnpauseBurningAndMintingResponse, error) {
	out := new(MsgUnpauseBurningAndMintingResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/UnpauseBurningAndMinting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PauseSendingAndReceivingMessages(ctx context.Context, in *MsgPauseSendingAndReceivingMessages, opts ...grpc.CallOption) (*MsgPauseSendingAndReceivingMessagesResponse, error) {
	out := new(MsgPauseSendingAndReceivingMessagesResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/PauseSendingAndReceivingMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UnpauseSendingAndReceivingMessages(ctx context.Context, in *MsgUnpauseSendingAndReceivingMessages, opts ...grpc.CallOption) (*MsgUnpauseSendingAndReceivingMessagesResponse, error) {
	out := new(MsgUnpauseSendingAndReceivingMessagesResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/UnpauseSendingAndReceivingMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateMaxMessageBodySize(ctx context.Context, in *MsgUpdateMaxMessageBodySize, opts ...grpc.CallOption) (*MsgUpdateMaxMessageBodySizeResponse, error) {
	out := new(MsgUpdateMaxMessageBodySizeResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/UpdateMaxMessageBodySize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdatePerMessageBurnLimit(ctx context.Context, in *MsgUpdatePerMessageBurnLimit, opts ...grpc.CallOption) (*MsgUpdatePerMessageBurnLimitResponse, error) {
	out := new(MsgUpdatePerMessageBurnLimitResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/UpdatePerMessageBurnLimit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateSignatureThreshold(ctx context.Context, in *MsgUpdateSignatureThreshold, opts ...grpc.CallOption) (*MsgUpdateSignatureThresholdResponse, error) {
	out := new(MsgUpdateSignatureThresholdResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/UpdateSignatureThreshold", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateMinterAllowance(ctx context.Context, in *MsgUpdateMinterAllowance, opts ...grpc.CallOption) (*MsgUpdateMinterAllowanceResponse, error) {
	out := new(MsgUpdateMinterAllowanceResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/UpdateMinterAllowance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) LinkTokenPair(ctx context.Context, in *MsgLinkTokenPair, opts ...grpc.CallOption) (*MsgLinkTokenPairResponse, error) {
	out := new(MsgLinkTokenPairResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/LinkTokenPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UnlinkTokenPair(ctx context.Context, in *MsgUnlinkTokenPair, opts ...grpc.CallOption) (*MsgUnlinkTokenPairResponse, error) {
	out := new(MsgUnlinkTokenPairResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/UnlinkTokenPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DepositForBurn(ctx context.Context, in *MsgDepositForBurn, opts ...grpc.CallOption) (*MsgDepositForBurnResponse, error) {
	out := new(MsgDepositForBurnResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/DepositForBurn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DepositForBurnWithCaller(ctx context.Context, in *MsgDepositForBurnWithCaller, opts ...grpc.CallOption) (*MsgDepositForBurnWithCallerResponse, error) {
	out := new(MsgDepositForBurnWithCallerResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/DepositForBurnWithCaller", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReplaceDepositForBurn(ctx context.Context, in *MsgReplaceDepositForBurn, opts ...grpc.CallOption) (*MsgReplaceDepositForBurnResponse, error) {
	out := new(MsgReplaceDepositForBurnResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/ReplaceDepositForBurn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReceiveMessage(ctx context.Context, in *MsgReceiveMessage, opts ...grpc.CallOption) (*MsgReceiveMessageResponse, error) {
	out := new(MsgReceiveMessageResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/ReceiveMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SendMessage(ctx context.Context, in *MsgSendMessage, opts ...grpc.CallOption) (*MsgSendMessageResponse, error) {
	out := new(MsgSendMessageResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/SendMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SendMessageWithCaller(ctx context.Context, in *MsgSendMessageWithCaller, opts ...grpc.CallOption) (*MsgSendMessageWithCallerResponse, error) {
	out := new(MsgSendMessageWithCallerResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/SendMessageWithCaller", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReplaceMessage(ctx context.Context, in *MsgReplaceMessage, opts ...grpc.CallOption) (*MsgReplaceMessageResponse, error) {
	out := new(MsgReplaceMessageResponse)
	err := c.cc.Invoke(ctx, "/noble.cctp.Msg/ReplaceMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	UpdateAuthority(context.Context, *MsgUpdateAuthority) (*MsgUpdateAuthorityResponse, error)
	AddPublicKey(context.Context, *MsgAddPublicKey) (*MsgAddPublicKeyResponse, error)
	RemovePublicKey(context.Context, *MsgRemovePublicKey) (*MsgRemovePublicKeyResponse, error)
	PauseBurningAndMinting(context.Context, *MsgPauseBurningAndMinting) (*MsgPauseBurningAndMintingResponse, error)
	UnpauseBurningAndMinting(context.Context, *MsgUnpauseBurningAndMinting) (*MsgUnpauseBurningAndMintingResponse, error)
	PauseSendingAndReceivingMessages(context.Context, *MsgPauseSendingAndReceivingMessages) (*MsgPauseSendingAndReceivingMessagesResponse, error)
	UnpauseSendingAndReceivingMessages(context.Context, *MsgUnpauseSendingAndReceivingMessages) (*MsgUnpauseSendingAndReceivingMessagesResponse, error)
	UpdateMaxMessageBodySize(context.Context, *MsgUpdateMaxMessageBodySize) (*MsgUpdateMaxMessageBodySizeResponse, error)
	UpdatePerMessageBurnLimit(context.Context, *MsgUpdatePerMessageBurnLimit) (*MsgUpdatePerMessageBurnLimitResponse, error)
	UpdateSignatureThreshold(context.Context, *MsgUpdateSignatureThreshold) (*MsgUpdateSignatureThresholdResponse, error)
	UpdateMinterAllowance(context.Context, *MsgUpdateMinterAllowance) (*MsgUpdateMinterAllowanceResponse, error)
	LinkTokenPair(context.Context, *MsgLinkTokenPair) (*MsgLinkTokenPairResponse, error)
	UnlinkTokenPair(context.Context, *MsgUnlinkTokenPair) (*MsgUnlinkTokenPairResponse, error)
	DepositForBurn(context.Context, *MsgDepositForBurn) (*MsgDepositForBurnResponse, error)
	DepositForBurnWithCaller(context.Context, *MsgDepositForBurnWithCaller) (*MsgDepositForBurnWithCallerResponse, error)
	ReplaceDepositForBurn(context.Context, *MsgReplaceDepositForBurn) (*MsgReplaceDepositForBurnResponse, error)
	ReceiveMessage(context.Context, *MsgReceiveMessage) (*MsgReceiveMessageResponse, error)
	SendMessage(context.Context, *MsgSendMessage) (*MsgSendMessageResponse, error)
	SendMessageWithCaller(context.Context, *MsgSendMessageWithCaller) (*MsgSendMessageWithCallerResponse, error)
	ReplaceMessage(context.Context, *MsgReplaceMessage) (*MsgReplaceMessageResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateAuthority(ctx context.Context, req *MsgUpdateAuthority) (*MsgUpdateAuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAuthority not implemented")
}
func (*UnimplementedMsgServer) AddPublicKey(ctx context.Context, req *MsgAddPublicKey) (*MsgAddPublicKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPublicKey not implemented")
}
func (*UnimplementedMsgServer) RemovePublicKey(ctx context.Context, req *MsgRemovePublicKey) (*MsgRemovePublicKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePublicKey not implemented")
}
func (*UnimplementedMsgServer) PauseBurningAndMinting(ctx context.Context, req *MsgPauseBurningAndMinting) (*MsgPauseBurningAndMintingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseBurningAndMinting not implemented")
}
func (*UnimplementedMsgServer) UnpauseBurningAndMinting(ctx context.Context, req *MsgUnpauseBurningAndMinting) (*MsgUnpauseBurningAndMintingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnpauseBurningAndMinting not implemented")
}
func (*UnimplementedMsgServer) PauseSendingAndReceivingMessages(ctx context.Context, req *MsgPauseSendingAndReceivingMessages) (*MsgPauseSendingAndReceivingMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseSendingAndReceivingMessages not implemented")
}
func (*UnimplementedMsgServer) UnpauseSendingAndReceivingMessages(ctx context.Context, req *MsgUnpauseSendingAndReceivingMessages) (*MsgUnpauseSendingAndReceivingMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnpauseSendingAndReceivingMessages not implemented")
}
func (*UnimplementedMsgServer) UpdateMaxMessageBodySize(ctx context.Context, req *MsgUpdateMaxMessageBodySize) (*MsgUpdateMaxMessageBodySizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMaxMessageBodySize not implemented")
}
func (*UnimplementedMsgServer) UpdatePerMessageBurnLimit(ctx context.Context, req *MsgUpdatePerMessageBurnLimit) (*MsgUpdatePerMessageBurnLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePerMessageBurnLimit not implemented")
}
func (*UnimplementedMsgServer) UpdateSignatureThreshold(ctx context.Context, req *MsgUpdateSignatureThreshold) (*MsgUpdateSignatureThresholdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSignatureThreshold not implemented")
}
func (*UnimplementedMsgServer) UpdateMinterAllowance(ctx context.Context, req *MsgUpdateMinterAllowance) (*MsgUpdateMinterAllowanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMinterAllowance not implemented")
}
func (*UnimplementedMsgServer) LinkTokenPair(ctx context.Context, req *MsgLinkTokenPair) (*MsgLinkTokenPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkTokenPair not implemented")
}
func (*UnimplementedMsgServer) UnlinkTokenPair(ctx context.Context, req *MsgUnlinkTokenPair) (*MsgUnlinkTokenPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlinkTokenPair not implemented")
}
func (*UnimplementedMsgServer) DepositForBurn(ctx context.Context, req *MsgDepositForBurn) (*MsgDepositForBurnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositForBurn not implemented")
}
func (*UnimplementedMsgServer) DepositForBurnWithCaller(ctx context.Context, req *MsgDepositForBurnWithCaller) (*MsgDepositForBurnWithCallerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositForBurnWithCaller not implemented")
}
func (*UnimplementedMsgServer) ReplaceDepositForBurn(ctx context.Context, req *MsgReplaceDepositForBurn) (*MsgReplaceDepositForBurnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplaceDepositForBurn not implemented")
}
func (*UnimplementedMsgServer) ReceiveMessage(ctx context.Context, req *MsgReceiveMessage) (*MsgReceiveMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveMessage not implemented")
}
func (*UnimplementedMsgServer) SendMessage(ctx context.Context, req *MsgSendMessage) (*MsgSendMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (*UnimplementedMsgServer) SendMessageWithCaller(ctx context.Context, req *MsgSendMessageWithCaller) (*MsgSendMessageWithCallerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessageWithCaller not implemented")
}
func (*UnimplementedMsgServer) ReplaceMessage(ctx context.Context, req *MsgReplaceMessage) (*MsgReplaceMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplaceMessage not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateAuthority)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/UpdateAuthority",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateAuthority(ctx, req.(*MsgUpdateAuthority))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddPublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/AddPublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddPublicKey(ctx, req.(*MsgAddPublicKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemovePublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemovePublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemovePublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/RemovePublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemovePublicKey(ctx, req.(*MsgRemovePublicKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PauseBurningAndMinting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPauseBurningAndMinting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PauseBurningAndMinting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/PauseBurningAndMinting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PauseBurningAndMinting(ctx, req.(*MsgPauseBurningAndMinting))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UnpauseBurningAndMinting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUnpauseBurningAndMinting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UnpauseBurningAndMinting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/UnpauseBurningAndMinting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UnpauseBurningAndMinting(ctx, req.(*MsgUnpauseBurningAndMinting))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PauseSendingAndReceivingMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPauseSendingAndReceivingMessages)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PauseSendingAndReceivingMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/PauseSendingAndReceivingMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PauseSendingAndReceivingMessages(ctx, req.(*MsgPauseSendingAndReceivingMessages))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UnpauseSendingAndReceivingMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUnpauseSendingAndReceivingMessages)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UnpauseSendingAndReceivingMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/UnpauseSendingAndReceivingMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UnpauseSendingAndReceivingMessages(ctx, req.(*MsgUnpauseSendingAndReceivingMessages))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateMaxMessageBodySize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateMaxMessageBodySize)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateMaxMessageBodySize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/UpdateMaxMessageBodySize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateMaxMessageBodySize(ctx, req.(*MsgUpdateMaxMessageBodySize))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdatePerMessageBurnLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdatePerMessageBurnLimit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdatePerMessageBurnLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/UpdatePerMessageBurnLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdatePerMessageBurnLimit(ctx, req.(*MsgUpdatePerMessageBurnLimit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateSignatureThreshold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateSignatureThreshold)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateSignatureThreshold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/UpdateSignatureThreshold",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateSignatureThreshold(ctx, req.(*MsgUpdateSignatureThreshold))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateMinterAllowance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateMinterAllowance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateMinterAllowance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/UpdateMinterAllowance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateMinterAllowance(ctx, req.(*MsgUpdateMinterAllowance))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_LinkTokenPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgLinkTokenPair)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).LinkTokenPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/LinkTokenPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).LinkTokenPair(ctx, req.(*MsgLinkTokenPair))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UnlinkTokenPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUnlinkTokenPair)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UnlinkTokenPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/UnlinkTokenPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UnlinkTokenPair(ctx, req.(*MsgUnlinkTokenPair))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DepositForBurn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDepositForBurn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DepositForBurn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/DepositForBurn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DepositForBurn(ctx, req.(*MsgDepositForBurn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DepositForBurnWithCaller_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDepositForBurnWithCaller)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DepositForBurnWithCaller(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/DepositForBurnWithCaller",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DepositForBurnWithCaller(ctx, req.(*MsgDepositForBurnWithCaller))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReplaceDepositForBurn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReplaceDepositForBurn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReplaceDepositForBurn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/ReplaceDepositForBurn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReplaceDepositForBurn(ctx, req.(*MsgReplaceDepositForBurn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReceiveMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReceiveMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReceiveMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/ReceiveMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReceiveMessage(ctx, req.(*MsgReceiveMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSendMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/SendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SendMessage(ctx, req.(*MsgSendMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SendMessageWithCaller_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSendMessageWithCaller)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SendMessageWithCaller(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/SendMessageWithCaller",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SendMessageWithCaller(ctx, req.(*MsgSendMessageWithCaller))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReplaceMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReplaceMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReplaceMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.cctp.Msg/ReplaceMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReplaceMessage(ctx, req.(*MsgReplaceMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "noble.cctp.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateAuthority",
			Handler:    _Msg_UpdateAuthority_Handler,
		},
		{
			MethodName: "AddPublicKey",
			Handler:    _Msg_AddPublicKey_Handler,
		},
		{
			MethodName: "RemovePublicKey",
			Handler:    _Msg_RemovePublicKey_Handler,
		},
		{
			MethodName: "PauseBurningAndMinting",
			Handler:    _Msg_PauseBurningAndMinting_Handler,
		},
		{
			MethodName: "UnpauseBurningAndMinting",
			Handler:    _Msg_UnpauseBurningAndMinting_Handler,
		},
		{
			MethodName: "PauseSendingAndReceivingMessages",
			Handler:    _Msg_PauseSendingAndReceivingMessages_Handler,
		},
		{
			MethodName: "UnpauseSendingAndReceivingMessages",
			Handler:    _Msg_UnpauseSendingAndReceivingMessages_Handler,
		},
		{
			MethodName: "UpdateMaxMessageBodySize",
			Handler:    _Msg_UpdateMaxMessageBodySize_Handler,
		},
		{
			MethodName: "UpdatePerMessageBurnLimit",
			Handler:    _Msg_UpdatePerMessageBurnLimit_Handler,
		},
		{
			MethodName: "UpdateSignatureThreshold",
			Handler:    _Msg_UpdateSignatureThreshold_Handler,
		},
		{
			MethodName: "UpdateMinterAllowance",
			Handler:    _Msg_UpdateMinterAllowance_Handler,
		},
		{
			MethodName: "LinkTokenPair",
			Handler:    _Msg_LinkTokenPair_Handler,
		},
		{
			MethodName: "UnlinkTokenPair",
			Handler:    _Msg_UnlinkTokenPair_Handler,
		},
		{
			MethodName: "DepositForBurn",
			Handler:    _Msg_DepositForBurn_Handler,
		},
		{
			MethodName: "DepositForBurnWithCaller",
			Handler:    _Msg_DepositForBurnWithCaller_Handler,
		},
		{
			MethodName: "ReplaceDepositForBurn",
			Handler:    _Msg_ReplaceDepositForBurn_Handler,
		},
		{
			MethodName: "ReceiveMessage",
			Handler:    _Msg_ReceiveMessage_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _Msg_SendMessage_Handler,
		},
		{
			MethodName: "SendMessageWithCaller",
			Handler:    _Msg_SendMessageWithCaller_Handler,
		},
		{
			MethodName: "ReplaceMessage",
			Handler:    _Msg_ReplaceMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cctp/tx.proto",
}

func (m *MsgUpdateAuthority) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateAuthority) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateAuthority) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAuthority) > 0 {
		i -= len(m.NewAuthority)
		copy(dAtA[i:], m.NewAuthority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewAuthority)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateAuthorityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateAuthorityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateAuthorityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAddPublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddPublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddPublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddPublicKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddPublicKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddPublicKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRemovePublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemovePublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemovePublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemovePublicKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemovePublicKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemovePublicKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPauseBurningAndMinting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPauseBurningAndMinting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPauseBurningAndMinting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPauseBurningAndMintingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPauseBurningAndMintingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPauseBurningAndMintingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUnpauseBurningAndMinting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUnpauseBurningAndMinting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUnpauseBurningAndMinting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUnpauseBurningAndMintingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUnpauseBurningAndMintingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUnpauseBurningAndMintingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPauseSendingAndReceivingMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPauseSendingAndReceivingMessages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPauseSendingAndReceivingMessages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPauseSendingAndReceivingMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPauseSendingAndReceivingMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPauseSendingAndReceivingMessagesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUnpauseSendingAndReceivingMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUnpauseSendingAndReceivingMessages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUnpauseSendingAndReceivingMessages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUnpauseSendingAndReceivingMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUnpauseSendingAndReceivingMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUnpauseSendingAndReceivingMessagesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateMaxMessageBodySize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateMaxMessageBodySize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateMaxMessageBodySize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateMaxMessageBodySizeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateMaxMessageBodySizeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateMaxMessageBodySizeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdatePerMessageBurnLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdatePerMessageBurnLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdatePerMessageBurnLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PerMessageBurnLimit != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PerMessageBurnLimit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdatePerMessageBurnLimitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdatePerMessageBurnLimitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdatePerMessageBurnLimitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDepositForBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositForBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositForBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BurnToken) > 0 {
		i -= len(m.BurnToken)
		copy(dAtA[i:], m.BurnToken)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BurnToken)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MintRecipient) > 0 {
		i -= len(m.MintRecipient)
		copy(dAtA[i:], m.MintRecipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MintRecipient)))
		i--
		dAtA[i] = 0x22
	}
	if m.DestinationDomain != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DestinationDomain))
		i--
		dAtA[i] = 0x18
	}
	if m.Amount != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositForBurnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositForBurnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositForBurnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositForBurnWithCaller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositForBurnWithCaller) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositForBurnWithCaller) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DestinationCaller) > 0 {
		i -= len(m.DestinationCaller)
		copy(dAtA[i:], m.DestinationCaller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DestinationCaller)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BurnToken) > 0 {
		i -= len(m.BurnToken)
		copy(dAtA[i:], m.BurnToken)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BurnToken)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MintRecipient) > 0 {
		i -= len(m.MintRecipient)
		copy(dAtA[i:], m.MintRecipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MintRecipient)))
		i--
		dAtA[i] = 0x22
	}
	if m.DestinationDomain != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DestinationDomain))
		i--
		dAtA[i] = 0x18
	}
	if m.Amount != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositForBurnWithCallerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositForBurnWithCallerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositForBurnWithCallerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgReplaceDepositForBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReplaceDepositForBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReplaceDepositForBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewMintRecipient) > 0 {
		i -= len(m.NewMintRecipient)
		copy(dAtA[i:], m.NewMintRecipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewMintRecipient)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewDestinationCaller) > 0 {
		i -= len(m.NewDestinationCaller)
		copy(dAtA[i:], m.NewDestinationCaller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewDestinationCaller)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OriginalAttestation) > 0 {
		i -= len(m.OriginalAttestation)
		copy(dAtA[i:], m.OriginalAttestation)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OriginalAttestation)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OriginalMessage) > 0 {
		i -= len(m.OriginalMessage)
		copy(dAtA[i:], m.OriginalMessage)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OriginalMessage)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReplaceDepositForBurnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReplaceDepositForBurnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReplaceDepositForBurnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgReceiveMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReceiveMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReceiveMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attestation) > 0 {
		i -= len(m.Attestation)
		copy(dAtA[i:], m.Attestation)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Attestation)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReceiveMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReceiveMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReceiveMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MessageBody) > 0 {
		i -= len(m.MessageBody)
		copy(dAtA[i:], m.MessageBody)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MessageBody)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DestinationDomain != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DestinationDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendMessageWithCaller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendMessageWithCaller) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendMessageWithCaller) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DestinationCaller) > 0 {
		i -= len(m.DestinationCaller)
		copy(dAtA[i:], m.DestinationCaller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DestinationCaller)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MessageBody) > 0 {
		i -= len(m.MessageBody)
		copy(dAtA[i:], m.MessageBody)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MessageBody)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DestinationDomain != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DestinationDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendMessageWithCallerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendMessageWithCallerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendMessageWithCallerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgReplaceMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReplaceMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReplaceMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewDestinationCaller) > 0 {
		i -= len(m.NewDestinationCaller)
		copy(dAtA[i:], m.NewDestinationCaller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewDestinationCaller)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewMessageBody) > 0 {
		i -= len(m.NewMessageBody)
		copy(dAtA[i:], m.NewMessageBody)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewMessageBody)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OriginalAttestation) > 0 {
		i -= len(m.OriginalAttestation)
		copy(dAtA[i:], m.OriginalAttestation)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OriginalAttestation)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OriginalMessage) > 0 {
		i -= len(m.OriginalMessage)
		copy(dAtA[i:], m.OriginalMessage)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OriginalMessage)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReplaceMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReplaceMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReplaceMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateSignatureThreshold) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateSignatureThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateSignatureThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateSignatureThresholdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateSignatureThresholdResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateSignatureThresholdResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateMinterAllowance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateMinterAllowance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateMinterAllowance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateMinterAllowanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateMinterAllowanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateMinterAllowanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgLinkTokenPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLinkTokenPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLinkTokenPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LocalToken) > 0 {
		i -= len(m.LocalToken)
		copy(dAtA[i:], m.LocalToken)
		i = encodeVarintTx(dAtA, i, uint64(len(m.LocalToken)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RemoteToken) > 0 {
		i -= len(m.RemoteToken)
		copy(dAtA[i:], m.RemoteToken)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RemoteToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RemoteDomain != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RemoteDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgLinkTokenPairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLinkTokenPairResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLinkTokenPairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUnlinkTokenPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUnlinkTokenPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUnlinkTokenPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LocalToken) > 0 {
		i -= len(m.LocalToken)
		copy(dAtA[i:], m.LocalToken)
		i = encodeVarintTx(dAtA, i, uint64(len(m.LocalToken)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RemoteToken) > 0 {
		i -= len(m.RemoteToken)
		copy(dAtA[i:], m.RemoteToken)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RemoteToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RemoteDomain != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RemoteDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUnlinkTokenPairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUnlinkTokenPairResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUnlinkTokenPairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateAuthority) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewAuthority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateAuthorityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAddPublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddPublicKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRemovePublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRemovePublicKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPauseBurningAndMinting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPauseBurningAndMintingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUnpauseBurningAndMinting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUnpauseBurningAndMintingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPauseSendingAndReceivingMessages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPauseSendingAndReceivingMessagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUnpauseSendingAndReceivingMessages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUnpauseSendingAndReceivingMessagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateMaxMessageBodySize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTx(uint64(m.Size_))
	}
	return n
}

func (m *MsgUpdateMaxMessageBodySizeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdatePerMessageBurnLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PerMessageBurnLimit != 0 {
		n += 1 + sovTx(uint64(m.PerMessageBurnLimit))
	}
	return n
}

func (m *MsgUpdatePerMessageBurnLimitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDepositForBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovTx(uint64(m.Amount))
	}
	if m.DestinationDomain != 0 {
		n += 1 + sovTx(uint64(m.DestinationDomain))
	}
	l = len(m.MintRecipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BurnToken)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDepositForBurnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	return n
}

func (m *MsgDepositForBurnWithCaller) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovTx(uint64(m.Amount))
	}
	if m.DestinationDomain != 0 {
		n += 1 + sovTx(uint64(m.DestinationDomain))
	}
	l = len(m.MintRecipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BurnToken)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DestinationCaller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDepositForBurnWithCallerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	return n
}

func (m *MsgReplaceDepositForBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OriginalMessage)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OriginalAttestation)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewDestinationCaller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewMintRecipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgReplaceDepositForBurnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgReceiveMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Attestation)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgReceiveMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *MsgSendMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DestinationDomain != 0 {
		n += 1 + sovTx(uint64(m.DestinationDomain))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MessageBody)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSendMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	return n
}

func (m *MsgSendMessageWithCaller) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DestinationDomain != 0 {
		n += 1 + sovTx(uint64(m.DestinationDomain))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MessageBody)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DestinationCaller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSendMessageWithCallerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	return n
}

func (m *MsgReplaceMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OriginalMessage)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OriginalAttestation)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewMessageBody)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewDestinationCaller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgReplaceMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateSignatureThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovTx(uint64(m.Amount))
	}
	return n
}

func (m *MsgUpdateSignatureThresholdResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateMinterAllowance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovTx(uint64(m.Amount))
	}
	return n
}

func (m *MsgUpdateMinterAllowanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgLinkTokenPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RemoteDomain != 0 {
		n += 1 + sovTx(uint64(m.RemoteDomain))
	}
	l = len(m.RemoteToken)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.LocalToken)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgLinkTokenPairResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUnlinkTokenPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RemoteDomain != 0 {
		n += 1 + sovTx(uint64(m.RemoteDomain))
	}
	l = len(m.RemoteToken)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.LocalToken)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUnlinkTokenPairResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateAuthority) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateAuthority: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateAuthority: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateAuthorityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateAuthorityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateAuthorityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddPublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddPublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddPublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddPublicKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddPublicKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddPublicKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemovePublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemovePublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemovePublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemovePublicKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemovePublicKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemovePublicKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPauseBurningAndMinting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPauseBurningAndMinting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPauseBurningAndMinting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPauseBurningAndMintingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPauseBurningAndMintingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPauseBurningAndMintingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUnpauseBurningAndMinting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUnpauseBurningAndMinting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUnpauseBurningAndMinting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUnpauseBurningAndMintingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUnpauseBurningAndMintingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUnpauseBurningAndMintingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPauseSendingAndReceivingMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPauseSendingAndReceivingMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPauseSendingAndReceivingMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPauseSendingAndReceivingMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPauseSendingAndReceivingMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPauseSendingAndReceivingMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUnpauseSendingAndReceivingMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUnpauseSendingAndReceivingMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUnpauseSendingAndReceivingMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUnpauseSendingAndReceivingMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUnpauseSendingAndReceivingMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUnpauseSendingAndReceivingMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateMaxMessageBodySize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateMaxMessageBodySize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateMaxMessageBodySize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateMaxMessageBodySizeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateMaxMessageBodySizeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateMaxMessageBodySizeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdatePerMessageBurnLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdatePerMessageBurnLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdatePerMessageBurnLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerMessageBurnLimit", wireType)
			}
			m.PerMessageBurnLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerMessageBurnLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdatePerMessageBurnLimitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdatePerMessageBurnLimitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdatePerMessageBurnLimitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositForBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositForBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositForBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
			}
			m.DestinationDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintRecipient", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintRecipient = append(m.MintRecipient[:0], dAtA[iNdEx:postIndex]...)
			if m.MintRecipient == nil {
				m.MintRecipient = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositForBurnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositForBurnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositForBurnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositForBurnWithCaller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositForBurnWithCaller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositForBurnWithCaller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
			}
			m.DestinationDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintRecipient", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintRecipient = append(m.MintRecipient[:0], dAtA[iNdEx:postIndex]...)
			if m.MintRecipient == nil {
				m.MintRecipient = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCaller", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationCaller = append(m.DestinationCaller[:0], dAtA[iNdEx:postIndex]...)
			if m.DestinationCaller == nil {
				m.DestinationCaller = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositForBurnWithCallerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositForBurnWithCallerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositForBurnWithCallerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReplaceDepositForBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReplaceDepositForBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReplaceDepositForBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalMessage = append(m.OriginalMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalMessage == nil {
				m.OriginalMessage = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAttestation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalAttestation = append(m.OriginalAttestation[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalAttestation == nil {
				m.OriginalAttestation = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDestinationCaller", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewDestinationCaller = append(m.NewDestinationCaller[:0], dAtA[iNdEx:postIndex]...)
			if m.NewDestinationCaller == nil {
				m.NewDestinationCaller = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMintRecipient", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewMintRecipient = append(m.NewMintRecipient[:0], dAtA[iNdEx:postIndex]...)
			if m.NewMintRecipient == nil {
				m.NewMintRecipient = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReplaceDepositForBurnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReplaceDepositForBurnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReplaceDepositForBurnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReceiveMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReceiveMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReceiveMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestation = append(m.Attestation[:0], dAtA[iNdEx:postIndex]...)
			if m.Attestation == nil {
				m.Attestation = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReceiveMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReceiveMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReceiveMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
			}
			m.DestinationDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = append(m.Recipient[:0], dAtA[iNdEx:postIndex]...)
			if m.Recipient == nil {
				m.Recipient = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageBody = append(m.MessageBody[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageBody == nil {
				m.MessageBody = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendMessageWithCaller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendMessageWithCaller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendMessageWithCaller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
			}
			m.DestinationDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = append(m.Recipient[:0], dAtA[iNdEx:postIndex]...)
			if m.Recipient == nil {
				m.Recipient = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageBody = append(m.MessageBody[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageBody == nil {
				m.MessageBody = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCaller", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationCaller = append(m.DestinationCaller[:0], dAtA[iNdEx:postIndex]...)
			if m.DestinationCaller == nil {
				m.DestinationCaller = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendMessageWithCallerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendMessageWithCallerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendMessageWithCallerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReplaceMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReplaceMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReplaceMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalMessage = append(m.OriginalMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalMessage == nil {
				m.OriginalMessage = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAttestation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalAttestation = append(m.OriginalAttestation[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalAttestation == nil {
				m.OriginalAttestation = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMessageBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewMessageBody = append(m.NewMessageBody[:0], dAtA[iNdEx:postIndex]...)
			if m.NewMessageBody == nil {
				m.NewMessageBody = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDestinationCaller", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewDestinationCaller = append(m.NewDestinationCaller[:0], dAtA[iNdEx:postIndex]...)
			if m.NewDestinationCaller == nil {
				m.NewDestinationCaller = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReplaceMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReplaceMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReplaceMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateSignatureThreshold) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateSignatureThreshold: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateSignatureThreshold: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateSignatureThresholdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateSignatureThresholdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateSignatureThresholdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateMinterAllowance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateMinterAllowance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateMinterAllowance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateMinterAllowanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateMinterAllowanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateMinterAllowanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLinkTokenPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLinkTokenPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLinkTokenPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDomain", wireType)
			}
			m.RemoteDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLinkTokenPairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLinkTokenPairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLinkTokenPairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUnlinkTokenPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUnlinkTokenPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUnlinkTokenPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDomain", wireType)
			}
			m.RemoteDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUnlinkTokenPairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUnlinkTokenPairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUnlinkTokenPairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
