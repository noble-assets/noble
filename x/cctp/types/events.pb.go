// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: circle/cctp/v1/events.proto

package types

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Event signatures in the CCTP module
type AttesterEnabled struct {
	Attester string `protobuf:"bytes,1,opt,name=attester,proto3" json:"attester,omitempty"`
}

func (m *AttesterEnabled) Reset()         { *m = AttesterEnabled{} }
func (m *AttesterEnabled) String() string { return proto.CompactTextString(m) }
func (*AttesterEnabled) ProtoMessage()    {}
func (*AttesterEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{0}
}
func (m *AttesterEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttesterEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttesterEnabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttesterEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttesterEnabled.Merge(m, src)
}
func (m *AttesterEnabled) XXX_Size() int {
	return m.Size()
}
func (m *AttesterEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_AttesterEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_AttesterEnabled proto.InternalMessageInfo

func (m *AttesterEnabled) GetAttester() string {
	if m != nil {
		return m.Attester
	}
	return ""
}

type AttesterDisabled struct {
	Attester string `protobuf:"bytes,1,opt,name=attester,proto3" json:"attester,omitempty"`
}

func (m *AttesterDisabled) Reset()         { *m = AttesterDisabled{} }
func (m *AttesterDisabled) String() string { return proto.CompactTextString(m) }
func (*AttesterDisabled) ProtoMessage()    {}
func (*AttesterDisabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{1}
}
func (m *AttesterDisabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttesterDisabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttesterDisabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttesterDisabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttesterDisabled.Merge(m, src)
}
func (m *AttesterDisabled) XXX_Size() int {
	return m.Size()
}
func (m *AttesterDisabled) XXX_DiscardUnknown() {
	xxx_messageInfo_AttesterDisabled.DiscardUnknown(m)
}

var xxx_messageInfo_AttesterDisabled proto.InternalMessageInfo

func (m *AttesterDisabled) GetAttester() string {
	if m != nil {
		return m.Attester
	}
	return ""
}

type SignatureThresholdUpdated struct {
	OldSignatureThreshold uint64 `protobuf:"varint,1,opt,name=old_signature_threshold,json=oldSignatureThreshold,proto3" json:"old_signature_threshold,omitempty"`
	NewSignatureThreshold uint64 `protobuf:"varint,2,opt,name=new_signature_threshold,json=newSignatureThreshold,proto3" json:"new_signature_threshold,omitempty"`
}

func (m *SignatureThresholdUpdated) Reset()         { *m = SignatureThresholdUpdated{} }
func (m *SignatureThresholdUpdated) String() string { return proto.CompactTextString(m) }
func (*SignatureThresholdUpdated) ProtoMessage()    {}
func (*SignatureThresholdUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{2}
}
func (m *SignatureThresholdUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureThresholdUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureThresholdUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureThresholdUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureThresholdUpdated.Merge(m, src)
}
func (m *SignatureThresholdUpdated) XXX_Size() int {
	return m.Size()
}
func (m *SignatureThresholdUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureThresholdUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureThresholdUpdated proto.InternalMessageInfo

func (m *SignatureThresholdUpdated) GetOldSignatureThreshold() uint64 {
	if m != nil {
		return m.OldSignatureThreshold
	}
	return 0
}

func (m *SignatureThresholdUpdated) GetNewSignatureThreshold() uint64 {
	if m != nil {
		return m.NewSignatureThreshold
	}
	return 0
}

type AuthorityUpdated struct {
	PreviousAuthority string `protobuf:"bytes,1,opt,name=previous_authority,json=previousAuthority,proto3" json:"previous_authority,omitempty"`
	NewAuthority      string `protobuf:"bytes,2,opt,name=new_authority,json=newAuthority,proto3" json:"new_authority,omitempty"`
}

func (m *AuthorityUpdated) Reset()         { *m = AuthorityUpdated{} }
func (m *AuthorityUpdated) String() string { return proto.CompactTextString(m) }
func (*AuthorityUpdated) ProtoMessage()    {}
func (*AuthorityUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{3}
}
func (m *AuthorityUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorityUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorityUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorityUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorityUpdated.Merge(m, src)
}
func (m *AuthorityUpdated) XXX_Size() int {
	return m.Size()
}
func (m *AuthorityUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorityUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorityUpdated proto.InternalMessageInfo

func (m *AuthorityUpdated) GetPreviousAuthority() string {
	if m != nil {
		return m.PreviousAuthority
	}
	return ""
}

func (m *AuthorityUpdated) GetNewAuthority() string {
	if m != nil {
		return m.NewAuthority
	}
	return ""
}

type PauseBurningAndMinting struct {
}

func (m *PauseBurningAndMinting) Reset()         { *m = PauseBurningAndMinting{} }
func (m *PauseBurningAndMinting) String() string { return proto.CompactTextString(m) }
func (*PauseBurningAndMinting) ProtoMessage()    {}
func (*PauseBurningAndMinting) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{4}
}
func (m *PauseBurningAndMinting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PauseBurningAndMinting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PauseBurningAndMinting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PauseBurningAndMinting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PauseBurningAndMinting.Merge(m, src)
}
func (m *PauseBurningAndMinting) XXX_Size() int {
	return m.Size()
}
func (m *PauseBurningAndMinting) XXX_DiscardUnknown() {
	xxx_messageInfo_PauseBurningAndMinting.DiscardUnknown(m)
}

var xxx_messageInfo_PauseBurningAndMinting proto.InternalMessageInfo

type UnpauseBurningAndMinting struct {
}

func (m *UnpauseBurningAndMinting) Reset()         { *m = UnpauseBurningAndMinting{} }
func (m *UnpauseBurningAndMinting) String() string { return proto.CompactTextString(m) }
func (*UnpauseBurningAndMinting) ProtoMessage()    {}
func (*UnpauseBurningAndMinting) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{5}
}
func (m *UnpauseBurningAndMinting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnpauseBurningAndMinting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnpauseBurningAndMinting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnpauseBurningAndMinting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnpauseBurningAndMinting.Merge(m, src)
}
func (m *UnpauseBurningAndMinting) XXX_Size() int {
	return m.Size()
}
func (m *UnpauseBurningAndMinting) XXX_DiscardUnknown() {
	xxx_messageInfo_UnpauseBurningAndMinting.DiscardUnknown(m)
}

var xxx_messageInfo_UnpauseBurningAndMinting proto.InternalMessageInfo

type PauseSendingAndReceiving struct {
}

func (m *PauseSendingAndReceiving) Reset()         { *m = PauseSendingAndReceiving{} }
func (m *PauseSendingAndReceiving) String() string { return proto.CompactTextString(m) }
func (*PauseSendingAndReceiving) ProtoMessage()    {}
func (*PauseSendingAndReceiving) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{6}
}
func (m *PauseSendingAndReceiving) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PauseSendingAndReceiving) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PauseSendingAndReceiving.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PauseSendingAndReceiving) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PauseSendingAndReceiving.Merge(m, src)
}
func (m *PauseSendingAndReceiving) XXX_Size() int {
	return m.Size()
}
func (m *PauseSendingAndReceiving) XXX_DiscardUnknown() {
	xxx_messageInfo_PauseSendingAndReceiving.DiscardUnknown(m)
}

var xxx_messageInfo_PauseSendingAndReceiving proto.InternalMessageInfo

type UnpauseSendingAndReceiving struct {
}

func (m *UnpauseSendingAndReceiving) Reset()         { *m = UnpauseSendingAndReceiving{} }
func (m *UnpauseSendingAndReceiving) String() string { return proto.CompactTextString(m) }
func (*UnpauseSendingAndReceiving) ProtoMessage()    {}
func (*UnpauseSendingAndReceiving) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{7}
}
func (m *UnpauseSendingAndReceiving) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnpauseSendingAndReceiving) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnpauseSendingAndReceiving.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnpauseSendingAndReceiving) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnpauseSendingAndReceiving.Merge(m, src)
}
func (m *UnpauseSendingAndReceiving) XXX_Size() int {
	return m.Size()
}
func (m *UnpauseSendingAndReceiving) XXX_DiscardUnknown() {
	xxx_messageInfo_UnpauseSendingAndReceiving.DiscardUnknown(m)
}

var xxx_messageInfo_UnpauseSendingAndReceiving proto.InternalMessageInfo

type DepositForBurn struct {
	Nonce                     uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	BurnToken                 string `protobuf:"bytes,2,opt,name=burn_token,json=burnToken,proto3" json:"burn_token,omitempty"`
	Amount                    uint64 `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
	Depositor                 string `protobuf:"bytes,4,opt,name=depositor,proto3" json:"depositor,omitempty"`
	MintRecipient             []byte `protobuf:"bytes,5,opt,name=mint_recipient,json=mintRecipient,proto3" json:"mint_recipient,omitempty"`
	DestinationDomain         uint32 `protobuf:"varint,6,opt,name=destination_domain,json=destinationDomain,proto3" json:"destination_domain,omitempty"`
	DestinationTokenMessenger []byte `protobuf:"bytes,7,opt,name=destination_token_messenger,json=destinationTokenMessenger,proto3" json:"destination_token_messenger,omitempty"`
	DestinationCaller         []byte `protobuf:"bytes,8,opt,name=destination_caller,json=destinationCaller,proto3" json:"destination_caller,omitempty"`
}

func (m *DepositForBurn) Reset()         { *m = DepositForBurn{} }
func (m *DepositForBurn) String() string { return proto.CompactTextString(m) }
func (*DepositForBurn) ProtoMessage()    {}
func (*DepositForBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{8}
}
func (m *DepositForBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositForBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositForBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositForBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositForBurn.Merge(m, src)
}
func (m *DepositForBurn) XXX_Size() int {
	return m.Size()
}
func (m *DepositForBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositForBurn.DiscardUnknown(m)
}

var xxx_messageInfo_DepositForBurn proto.InternalMessageInfo

func (m *DepositForBurn) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *DepositForBurn) GetBurnToken() string {
	if m != nil {
		return m.BurnToken
	}
	return ""
}

func (m *DepositForBurn) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *DepositForBurn) GetDepositor() string {
	if m != nil {
		return m.Depositor
	}
	return ""
}

func (m *DepositForBurn) GetMintRecipient() []byte {
	if m != nil {
		return m.MintRecipient
	}
	return nil
}

func (m *DepositForBurn) GetDestinationDomain() uint32 {
	if m != nil {
		return m.DestinationDomain
	}
	return 0
}

func (m *DepositForBurn) GetDestinationTokenMessenger() []byte {
	if m != nil {
		return m.DestinationTokenMessenger
	}
	return nil
}

func (m *DepositForBurn) GetDestinationCaller() []byte {
	if m != nil {
		return m.DestinationCaller
	}
	return nil
}

type MintAndWithdraw struct {
	MintRecipient string `protobuf:"bytes,1,opt,name=mint_recipient,json=mintRecipient,proto3" json:"mint_recipient,omitempty"`
	Amount        uint64 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	MintToken     string `protobuf:"bytes,3,opt,name=mint_token,json=mintToken,proto3" json:"mint_token,omitempty"`
}

func (m *MintAndWithdraw) Reset()         { *m = MintAndWithdraw{} }
func (m *MintAndWithdraw) String() string { return proto.CompactTextString(m) }
func (*MintAndWithdraw) ProtoMessage()    {}
func (*MintAndWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{9}
}
func (m *MintAndWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MintAndWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MintAndWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MintAndWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MintAndWithdraw.Merge(m, src)
}
func (m *MintAndWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *MintAndWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_MintAndWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_MintAndWithdraw proto.InternalMessageInfo

func (m *MintAndWithdraw) GetMintRecipient() string {
	if m != nil {
		return m.MintRecipient
	}
	return ""
}

func (m *MintAndWithdraw) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *MintAndWithdraw) GetMintToken() string {
	if m != nil {
		return m.MintToken
	}
	return ""
}

type TokenPairLinked struct {
	LocalToken   string `protobuf:"bytes,1,opt,name=local_token,json=localToken,proto3" json:"local_token,omitempty"`
	RemoteDomain uint32 `protobuf:"varint,2,opt,name=remote_domain,json=remoteDomain,proto3" json:"remote_domain,omitempty"`
	RemoteToken  string `protobuf:"bytes,3,opt,name=remote_token,json=remoteToken,proto3" json:"remote_token,omitempty"`
}

func (m *TokenPairLinked) Reset()         { *m = TokenPairLinked{} }
func (m *TokenPairLinked) String() string { return proto.CompactTextString(m) }
func (*TokenPairLinked) ProtoMessage()    {}
func (*TokenPairLinked) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{10}
}
func (m *TokenPairLinked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenPairLinked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenPairLinked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenPairLinked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenPairLinked.Merge(m, src)
}
func (m *TokenPairLinked) XXX_Size() int {
	return m.Size()
}
func (m *TokenPairLinked) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenPairLinked.DiscardUnknown(m)
}

var xxx_messageInfo_TokenPairLinked proto.InternalMessageInfo

func (m *TokenPairLinked) GetLocalToken() string {
	if m != nil {
		return m.LocalToken
	}
	return ""
}

func (m *TokenPairLinked) GetRemoteDomain() uint32 {
	if m != nil {
		return m.RemoteDomain
	}
	return 0
}

func (m *TokenPairLinked) GetRemoteToken() string {
	if m != nil {
		return m.RemoteToken
	}
	return ""
}

type TokenPairUnlinked struct {
	LocalToken   string `protobuf:"bytes,1,opt,name=local_token,json=localToken,proto3" json:"local_token,omitempty"`
	RemoteDomain uint32 `protobuf:"varint,2,opt,name=remote_domain,json=remoteDomain,proto3" json:"remote_domain,omitempty"`
	RemoteToken  string `protobuf:"bytes,3,opt,name=remote_token,json=remoteToken,proto3" json:"remote_token,omitempty"`
}

func (m *TokenPairUnlinked) Reset()         { *m = TokenPairUnlinked{} }
func (m *TokenPairUnlinked) String() string { return proto.CompactTextString(m) }
func (*TokenPairUnlinked) ProtoMessage()    {}
func (*TokenPairUnlinked) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{11}
}
func (m *TokenPairUnlinked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenPairUnlinked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenPairUnlinked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenPairUnlinked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenPairUnlinked.Merge(m, src)
}
func (m *TokenPairUnlinked) XXX_Size() int {
	return m.Size()
}
func (m *TokenPairUnlinked) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenPairUnlinked.DiscardUnknown(m)
}

var xxx_messageInfo_TokenPairUnlinked proto.InternalMessageInfo

func (m *TokenPairUnlinked) GetLocalToken() string {
	if m != nil {
		return m.LocalToken
	}
	return ""
}

func (m *TokenPairUnlinked) GetRemoteDomain() uint32 {
	if m != nil {
		return m.RemoteDomain
	}
	return 0
}

func (m *TokenPairUnlinked) GetRemoteToken() string {
	if m != nil {
		return m.RemoteToken
	}
	return ""
}

type MessageSent struct {
	Message []byte `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *MessageSent) Reset()         { *m = MessageSent{} }
func (m *MessageSent) String() string { return proto.CompactTextString(m) }
func (*MessageSent) ProtoMessage()    {}
func (*MessageSent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{12}
}
func (m *MessageSent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageSent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageSent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageSent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageSent.Merge(m, src)
}
func (m *MessageSent) XXX_Size() int {
	return m.Size()
}
func (m *MessageSent) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageSent.DiscardUnknown(m)
}

var xxx_messageInfo_MessageSent proto.InternalMessageInfo

func (m *MessageSent) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

type MessageReceived struct {
	Caller       string `protobuf:"bytes,1,opt,name=caller,proto3" json:"caller,omitempty"`
	SourceDomain uint32 `protobuf:"varint,2,opt,name=source_domain,json=sourceDomain,proto3" json:"source_domain,omitempty"`
	Nonce        uint64 `protobuf:"varint,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Sender       []byte `protobuf:"bytes,4,opt,name=sender,proto3" json:"sender,omitempty"`
	MessageBody  []byte `protobuf:"bytes,5,opt,name=message_body,json=messageBody,proto3" json:"message_body,omitempty"`
}

func (m *MessageReceived) Reset()         { *m = MessageReceived{} }
func (m *MessageReceived) String() string { return proto.CompactTextString(m) }
func (*MessageReceived) ProtoMessage()    {}
func (*MessageReceived) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{13}
}
func (m *MessageReceived) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageReceived) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageReceived.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageReceived) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageReceived.Merge(m, src)
}
func (m *MessageReceived) XXX_Size() int {
	return m.Size()
}
func (m *MessageReceived) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageReceived.DiscardUnknown(m)
}

var xxx_messageInfo_MessageReceived proto.InternalMessageInfo

func (m *MessageReceived) GetCaller() string {
	if m != nil {
		return m.Caller
	}
	return ""
}

func (m *MessageReceived) GetSourceDomain() uint32 {
	if m != nil {
		return m.SourceDomain
	}
	return 0
}

func (m *MessageReceived) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *MessageReceived) GetSender() []byte {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MessageReceived) GetMessageBody() []byte {
	if m != nil {
		return m.MessageBody
	}
	return nil
}

type MaxMessageBodySizeUpdated struct {
	NewMaxMessageBodySize uint64 `protobuf:"varint,1,opt,name=new_max_message_body_size,json=newMaxMessageBodySize,proto3" json:"new_max_message_body_size,omitempty"`
}

func (m *MaxMessageBodySizeUpdated) Reset()         { *m = MaxMessageBodySizeUpdated{} }
func (m *MaxMessageBodySizeUpdated) String() string { return proto.CompactTextString(m) }
func (*MaxMessageBodySizeUpdated) ProtoMessage()    {}
func (*MaxMessageBodySizeUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{14}
}
func (m *MaxMessageBodySizeUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxMessageBodySizeUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxMessageBodySizeUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxMessageBodySizeUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxMessageBodySizeUpdated.Merge(m, src)
}
func (m *MaxMessageBodySizeUpdated) XXX_Size() int {
	return m.Size()
}
func (m *MaxMessageBodySizeUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxMessageBodySizeUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_MaxMessageBodySizeUpdated proto.InternalMessageInfo

func (m *MaxMessageBodySizeUpdated) GetNewMaxMessageBodySize() uint64 {
	if m != nil {
		return m.NewMaxMessageBodySize
	}
	return 0
}

type RemoteTokenMessengerAdded struct {
	Domain         uint32 `protobuf:"varint,1,opt,name=domain,proto3" json:"domain,omitempty"`
	TokenMessenger []byte `protobuf:"bytes,2,opt,name=tokenMessenger,proto3" json:"tokenMessenger,omitempty"`
}

func (m *RemoteTokenMessengerAdded) Reset()         { *m = RemoteTokenMessengerAdded{} }
func (m *RemoteTokenMessengerAdded) String() string { return proto.CompactTextString(m) }
func (*RemoteTokenMessengerAdded) ProtoMessage()    {}
func (*RemoteTokenMessengerAdded) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{15}
}
func (m *RemoteTokenMessengerAdded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteTokenMessengerAdded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteTokenMessengerAdded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteTokenMessengerAdded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteTokenMessengerAdded.Merge(m, src)
}
func (m *RemoteTokenMessengerAdded) XXX_Size() int {
	return m.Size()
}
func (m *RemoteTokenMessengerAdded) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteTokenMessengerAdded.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteTokenMessengerAdded proto.InternalMessageInfo

func (m *RemoteTokenMessengerAdded) GetDomain() uint32 {
	if m != nil {
		return m.Domain
	}
	return 0
}

func (m *RemoteTokenMessengerAdded) GetTokenMessenger() []byte {
	if m != nil {
		return m.TokenMessenger
	}
	return nil
}

type RemoteTokenMessengerRemoved struct {
	Domain         uint32 `protobuf:"varint,1,opt,name=domain,proto3" json:"domain,omitempty"`
	TokenMessenger []byte `protobuf:"bytes,2,opt,name=tokenMessenger,proto3" json:"tokenMessenger,omitempty"`
}

func (m *RemoteTokenMessengerRemoved) Reset()         { *m = RemoteTokenMessengerRemoved{} }
func (m *RemoteTokenMessengerRemoved) String() string { return proto.CompactTextString(m) }
func (*RemoteTokenMessengerRemoved) ProtoMessage()    {}
func (*RemoteTokenMessengerRemoved) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{16}
}
func (m *RemoteTokenMessengerRemoved) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteTokenMessengerRemoved) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteTokenMessengerRemoved.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteTokenMessengerRemoved) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteTokenMessengerRemoved.Merge(m, src)
}
func (m *RemoteTokenMessengerRemoved) XXX_Size() int {
	return m.Size()
}
func (m *RemoteTokenMessengerRemoved) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteTokenMessengerRemoved.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteTokenMessengerRemoved proto.InternalMessageInfo

func (m *RemoteTokenMessengerRemoved) GetDomain() uint32 {
	if m != nil {
		return m.Domain
	}
	return 0
}

func (m *RemoteTokenMessengerRemoved) GetTokenMessenger() []byte {
	if m != nil {
		return m.TokenMessenger
	}
	return nil
}

func init() {
	proto.RegisterType((*AttesterEnabled)(nil), "circle.cctp.v1.AttesterEnabled")
	proto.RegisterType((*AttesterDisabled)(nil), "circle.cctp.v1.AttesterDisabled")
	proto.RegisterType((*SignatureThresholdUpdated)(nil), "circle.cctp.v1.SignatureThresholdUpdated")
	proto.RegisterType((*AuthorityUpdated)(nil), "circle.cctp.v1.AuthorityUpdated")
	proto.RegisterType((*PauseBurningAndMinting)(nil), "circle.cctp.v1.PauseBurningAndMinting")
	proto.RegisterType((*UnpauseBurningAndMinting)(nil), "circle.cctp.v1.UnpauseBurningAndMinting")
	proto.RegisterType((*PauseSendingAndReceiving)(nil), "circle.cctp.v1.PauseSendingAndReceiving")
	proto.RegisterType((*UnpauseSendingAndReceiving)(nil), "circle.cctp.v1.UnpauseSendingAndReceiving")
	proto.RegisterType((*DepositForBurn)(nil), "circle.cctp.v1.DepositForBurn")
	proto.RegisterType((*MintAndWithdraw)(nil), "circle.cctp.v1.MintAndWithdraw")
	proto.RegisterType((*TokenPairLinked)(nil), "circle.cctp.v1.TokenPairLinked")
	proto.RegisterType((*TokenPairUnlinked)(nil), "circle.cctp.v1.TokenPairUnlinked")
	proto.RegisterType((*MessageSent)(nil), "circle.cctp.v1.MessageSent")
	proto.RegisterType((*MessageReceived)(nil), "circle.cctp.v1.MessageReceived")
	proto.RegisterType((*MaxMessageBodySizeUpdated)(nil), "circle.cctp.v1.MaxMessageBodySizeUpdated")
	proto.RegisterType((*RemoteTokenMessengerAdded)(nil), "circle.cctp.v1.RemoteTokenMessengerAdded")
	proto.RegisterType((*RemoteTokenMessengerRemoved)(nil), "circle.cctp.v1.RemoteTokenMessengerRemoved")
}

func init() { proto.RegisterFile("circle/cctp/v1/events.proto", fileDescriptor_e7ce5881ab629356) }

var fileDescriptor_e7ce5881ab629356 = []byte{
	// 784 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0x4d, 0x6f, 0xe3, 0x44,
	0x18, 0xae, 0xd3, 0xdd, 0xee, 0xf6, 0x6d, 0xda, 0x6e, 0x2d, 0x28, 0x4e, 0xbb, 0x1b, 0x8a, 0x57,
	0x40, 0x2f, 0x4d, 0xb4, 0x20, 0x21, 0x4e, 0x48, 0x29, 0x85, 0xd3, 0x46, 0x5a, 0xb9, 0x1b, 0x21,
	0x81, 0x90, 0x35, 0xf1, 0xbc, 0x24, 0xa3, 0xb5, 0x67, 0xac, 0x99, 0x71, 0xd2, 0x54, 0xfc, 0x03,
	0x2e, 0xfc, 0x03, 0xfe, 0x0a, 0x47, 0x8e, 0x3d, 0x72, 0x44, 0xed, 0x1f, 0x41, 0xf3, 0xe1, 0x24,
	0x4d, 0x83, 0x38, 0x20, 0x71, 0xf3, 0xfb, 0xbc, 0xcf, 0xf3, 0x7e, 0x3c, 0x33, 0xb6, 0xe1, 0x38,
	0x63, 0x32, 0xcb, 0xb1, 0x9b, 0x65, 0xba, 0xec, 0x4e, 0x5e, 0x75, 0x71, 0x82, 0x5c, 0xab, 0x4e,
	0x29, 0x85, 0x16, 0xe1, 0x9e, 0x4b, 0x76, 0x4c, 0xb2, 0x33, 0x79, 0x15, 0x9f, 0xc1, 0x7e, 0x4f,
	0x6b, 0x54, 0x1a, 0xe5, 0x37, 0x9c, 0x0c, 0x73, 0xa4, 0xe1, 0x11, 0x3c, 0x25, 0x1e, 0x8a, 0x82,
	0x93, 0xe0, 0x74, 0x3b, 0x99, 0xc7, 0x71, 0x07, 0x9e, 0xd5, 0xf4, 0x0b, 0xa6, 0xfe, 0x9d, 0xff,
	0x4b, 0x00, 0xad, 0x4b, 0x36, 0xe2, 0x44, 0x57, 0x12, 0xdf, 0x8e, 0x25, 0xaa, 0xb1, 0xc8, 0xe9,
	0xa0, 0xa4, 0x44, 0x23, 0x0d, 0xbf, 0x80, 0x0f, 0x44, 0x4e, 0x53, 0x55, 0x13, 0x52, 0x5d, 0x33,
	0x6c, 0xa1, 0x47, 0xc9, 0xfb, 0x22, 0xa7, 0x0f, 0xe5, 0x46, 0xc7, 0x71, 0xba, 0x56, 0xd7, 0x70,
	0x3a, 0x8e, 0xd3, 0x87, 0xba, 0xf8, 0x27, 0x78, 0xd6, 0xab, 0xf4, 0x58, 0x48, 0xa6, 0x67, 0xf5,
	0x0c, 0x67, 0x10, 0x96, 0x12, 0x27, 0x4c, 0x54, 0x2a, 0x25, 0x75, 0xd2, 0xef, 0x71, 0x50, 0x67,
	0xe6, 0xaa, 0xf0, 0x25, 0xec, 0x9a, 0xd6, 0x0b, 0x66, 0xc3, 0x32, 0x9b, 0x1c, 0xa7, 0x73, 0x52,
	0x1c, 0xc1, 0xe1, 0x1b, 0x52, 0x29, 0x3c, 0xaf, 0x24, 0x67, 0x7c, 0xd4, 0xe3, 0xb4, 0xcf, 0xb8,
	0x66, 0x7c, 0x14, 0x1f, 0x41, 0x34, 0xe0, 0xe5, 0x3f, 0xe6, 0xac, 0xea, 0x12, 0x39, 0x75, 0x99,
	0x04, 0x33, 0x64, 0x13, 0x93, 0x7b, 0x0e, 0x47, 0x5e, 0xb7, 0x2e, 0xfb, 0x7b, 0x03, 0xf6, 0x2e,
	0xb0, 0x14, 0x8a, 0xe9, 0x6f, 0x85, 0x34, 0x95, 0xc3, 0xf7, 0xe0, 0x31, 0x17, 0x3c, 0x43, 0x6f,
	0xa4, 0x0b, 0xc2, 0x17, 0x00, 0xc3, 0x4a, 0xf2, 0x54, 0x8b, 0x77, 0xc8, 0xfd, 0xe8, 0xdb, 0x06,
	0x79, 0x6b, 0x80, 0xf0, 0x10, 0xb6, 0x48, 0x21, 0x2a, 0xae, 0xa3, 0x4d, 0xab, 0xf2, 0x51, 0xf8,
	0x1c, 0xb6, 0xa9, 0x2b, 0x2f, 0x64, 0xf4, 0xc8, 0xa9, 0xe6, 0x40, 0xf8, 0x31, 0xec, 0x15, 0x8c,
	0xeb, 0x54, 0x62, 0xc6, 0x4a, 0x86, 0x5c, 0x47, 0x8f, 0x4f, 0x82, 0xd3, 0x66, 0xb2, 0x6b, 0xd0,
	0xa4, 0x06, 0x8d, 0xd1, 0x14, 0x95, 0x66, 0x9c, 0x68, 0x26, 0x78, 0x4a, 0x45, 0x41, 0x18, 0x8f,
	0xb6, 0x4e, 0x82, 0xd3, 0xdd, 0xe4, 0x60, 0x29, 0x73, 0x61, 0x13, 0xe1, 0x57, 0x70, 0xbc, 0x4c,
	0xb7, 0x13, 0xa7, 0x05, 0x2a, 0x85, 0x7c, 0x84, 0x32, 0x7a, 0x62, 0x5b, 0xb4, 0x96, 0x28, 0x76,
	0x85, 0x7e, 0x4d, 0x58, 0x6d, 0x97, 0x91, 0x3c, 0x47, 0x19, 0x3d, 0xb5, 0xb2, 0xe5, 0x76, 0x5f,
	0xdb, 0x44, 0x2c, 0x60, 0xdf, 0x9c, 0x43, 0x8f, 0xd3, 0xef, 0x98, 0x1e, 0x53, 0x49, 0xa6, 0x6b,
	0xf6, 0x72, 0xb7, 0x62, 0x65, 0xaf, 0x85, 0x69, 0x8d, 0x7b, 0xa6, 0xbd, 0x00, 0xb0, 0x72, 0xe7,
	0xf5, 0xa6, 0x73, 0xcd, 0x20, 0x76, 0xd0, 0xf8, 0x1a, 0xf6, 0xed, 0xc3, 0x1b, 0xc2, 0xe4, 0x6b,
	0xc6, 0xdf, 0x21, 0x0d, 0x3f, 0x84, 0x9d, 0x5c, 0x64, 0x24, 0xf7, 0x12, 0xd7, 0x0d, 0x2c, 0xe4,
	0xce, 0xe7, 0x25, 0xec, 0x4a, 0x2c, 0x84, 0xc6, 0xda, 0xbd, 0x86, 0x75, 0xaf, 0xe9, 0x40, 0x6f,
	0xdc, 0x47, 0xe0, 0xe3, 0x7b, 0x9d, 0x77, 0x1c, 0xe6, 0x7a, 0xff, 0x0c, 0x07, 0xf3, 0xde, 0x03,
	0x9e, 0xff, 0xcf, 0xdd, 0x3f, 0x85, 0x1d, 0x73, 0x4c, 0x64, 0x64, 0xee, 0xb2, 0x0e, 0x23, 0x78,
	0x52, 0xb8, 0xd0, 0xf6, 0x6c, 0x26, 0x75, 0x18, 0xff, 0x16, 0xc0, 0xbe, 0x67, 0xba, 0xbb, 0x8e,
	0xd4, 0xb8, 0xed, 0x8f, 0xd2, 0x0d, 0xe8, 0x23, 0x33, 0x9c, 0x12, 0x95, 0xcc, 0x56, 0x87, 0x73,
	0xa0, 0x1f, 0x6e, 0xfe, 0x52, 0x6c, 0x2e, 0xbf, 0x14, 0x87, 0xb0, 0xa5, 0x90, 0x53, 0x74, 0x57,
	0xbb, 0x99, 0xf8, 0xc8, 0xac, 0xe2, 0x27, 0x49, 0x87, 0x82, 0xce, 0xfc, 0xad, 0xde, 0xf1, 0xd8,
	0xb9, 0xa0, 0xb3, 0x78, 0x00, 0xad, 0x3e, 0xb9, 0xea, 0x2f, 0x90, 0x4b, 0x76, 0x8d, 0xf5, 0x97,
	0xe5, 0x4b, 0x68, 0x99, 0x4f, 0x45, 0x41, 0xae, 0xd2, 0xe5, 0x3a, 0xa9, 0x62, 0xd7, 0xf5, 0x6b,
	0x69, 0xbe, 0x53, 0x0f, 0x0b, 0xc4, 0x3f, 0x40, 0x2b, 0x59, 0x18, 0x36, 0xbf, 0xd3, 0x3d, 0x4a,
	0x9d, 0x03, 0x7e, 0xc5, 0xc0, 0xae, 0xe8, 0xa3, 0xf0, 0x13, 0xd8, 0xd3, 0xf7, 0xe8, 0xd6, 0x82,
	0x66, 0xb2, 0x82, 0xc6, 0x3f, 0xc2, 0xf1, 0xba, 0xe2, 0x06, 0x9b, 0xfc, 0xf7, 0xf2, 0xe7, 0xaf,
	0xff, 0xb8, 0x6d, 0x07, 0x37, 0xb7, 0xed, 0xe0, 0xaf, 0xdb, 0x76, 0xf0, 0xeb, 0x5d, 0x7b, 0xe3,
	0xe6, 0xae, 0xbd, 0xf1, 0xe7, 0x5d, 0x7b, 0xe3, 0xfb, 0xcf, 0x46, 0x4c, 0x8f, 0xab, 0x61, 0x27,
	0x13, 0x45, 0x57, 0x69, 0x49, 0xf8, 0x08, 0x73, 0x31, 0xc1, 0x33, 0xf3, 0x7b, 0xaa, 0x24, 0xaa,
	0x2e, 0x17, 0xc3, 0x1c, 0xbb, 0x57, 0xee, 0xc7, 0xa5, 0x67, 0x25, 0xaa, 0xe1, 0x96, 0xfd, 0x6b,
	0x7d, 0xfe, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4e, 0x10, 0x94, 0xe1, 0xd4, 0x06, 0x00, 0x00,
}

func (m *AttesterEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttesterEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttesterEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attester) > 0 {
		i -= len(m.Attester)
		copy(dAtA[i:], m.Attester)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Attester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttesterDisabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttesterDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttesterDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attester) > 0 {
		i -= len(m.Attester)
		copy(dAtA[i:], m.Attester)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Attester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignatureThresholdUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureThresholdUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureThresholdUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewSignatureThreshold != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.NewSignatureThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.OldSignatureThreshold != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OldSignatureThreshold))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthorityUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorityUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorityUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAuthority) > 0 {
		i -= len(m.NewAuthority)
		copy(dAtA[i:], m.NewAuthority)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewAuthority)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousAuthority) > 0 {
		i -= len(m.PreviousAuthority)
		copy(dAtA[i:], m.PreviousAuthority)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PreviousAuthority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PauseBurningAndMinting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PauseBurningAndMinting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PauseBurningAndMinting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UnpauseBurningAndMinting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnpauseBurningAndMinting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnpauseBurningAndMinting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *PauseSendingAndReceiving) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PauseSendingAndReceiving) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PauseSendingAndReceiving) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UnpauseSendingAndReceiving) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnpauseSendingAndReceiving) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnpauseSendingAndReceiving) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DepositForBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositForBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositForBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DestinationCaller) > 0 {
		i -= len(m.DestinationCaller)
		copy(dAtA[i:], m.DestinationCaller)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DestinationCaller)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DestinationTokenMessenger) > 0 {
		i -= len(m.DestinationTokenMessenger)
		copy(dAtA[i:], m.DestinationTokenMessenger)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DestinationTokenMessenger)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DestinationDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.DestinationDomain))
		i--
		dAtA[i] = 0x30
	}
	if len(m.MintRecipient) > 0 {
		i -= len(m.MintRecipient)
		copy(dAtA[i:], m.MintRecipient)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MintRecipient)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0x22
	}
	if m.Amount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BurnToken) > 0 {
		i -= len(m.BurnToken)
		copy(dAtA[i:], m.BurnToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BurnToken)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MintAndWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MintAndWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MintAndWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MintToken) > 0 {
		i -= len(m.MintToken)
		copy(dAtA[i:], m.MintToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MintToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Amount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MintRecipient) > 0 {
		i -= len(m.MintRecipient)
		copy(dAtA[i:], m.MintRecipient)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MintRecipient)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TokenPairLinked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenPairLinked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenPairLinked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoteToken) > 0 {
		i -= len(m.RemoteToken)
		copy(dAtA[i:], m.RemoteToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RemoteToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RemoteDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RemoteDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalToken) > 0 {
		i -= len(m.LocalToken)
		copy(dAtA[i:], m.LocalToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.LocalToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TokenPairUnlinked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenPairUnlinked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenPairUnlinked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoteToken) > 0 {
		i -= len(m.RemoteToken)
		copy(dAtA[i:], m.RemoteToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RemoteToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RemoteDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RemoteDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalToken) > 0 {
		i -= len(m.LocalToken)
		copy(dAtA[i:], m.LocalToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.LocalToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageSent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageSent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageSent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageReceived) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageReceived) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageReceived) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MessageBody) > 0 {
		i -= len(m.MessageBody)
		copy(dAtA[i:], m.MessageBody)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MessageBody)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x22
	}
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x18
	}
	if m.SourceDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SourceDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Caller) > 0 {
		i -= len(m.Caller)
		copy(dAtA[i:], m.Caller)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Caller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaxMessageBodySizeUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxMessageBodySizeUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxMessageBodySizeUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewMaxMessageBodySize != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.NewMaxMessageBodySize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoteTokenMessengerAdded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteTokenMessengerAdded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteTokenMessengerAdded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenMessenger) > 0 {
		i -= len(m.TokenMessenger)
		copy(dAtA[i:], m.TokenMessenger)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TokenMessenger)))
		i--
		dAtA[i] = 0x12
	}
	if m.Domain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoteTokenMessengerRemoved) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteTokenMessengerRemoved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteTokenMessengerRemoved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenMessenger) > 0 {
		i -= len(m.TokenMessenger)
		copy(dAtA[i:], m.TokenMessenger)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TokenMessenger)))
		i--
		dAtA[i] = 0x12
	}
	if m.Domain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AttesterEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attester)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *AttesterDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attester)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *SignatureThresholdUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OldSignatureThreshold != 0 {
		n += 1 + sovEvents(uint64(m.OldSignatureThreshold))
	}
	if m.NewSignatureThreshold != 0 {
		n += 1 + sovEvents(uint64(m.NewSignatureThreshold))
	}
	return n
}

func (m *AuthorityUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousAuthority)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewAuthority)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *PauseBurningAndMinting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UnpauseBurningAndMinting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PauseSendingAndReceiving) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UnpauseSendingAndReceiving) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DepositForBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	l = len(m.BurnToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovEvents(uint64(m.Amount))
	}
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MintRecipient)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.DestinationDomain != 0 {
		n += 1 + sovEvents(uint64(m.DestinationDomain))
	}
	l = len(m.DestinationTokenMessenger)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DestinationCaller)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MintAndWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MintRecipient)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovEvents(uint64(m.Amount))
	}
	l = len(m.MintToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *TokenPairLinked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RemoteDomain != 0 {
		n += 1 + sovEvents(uint64(m.RemoteDomain))
	}
	l = len(m.RemoteToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *TokenPairUnlinked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RemoteDomain != 0 {
		n += 1 + sovEvents(uint64(m.RemoteDomain))
	}
	l = len(m.RemoteToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MessageSent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MessageReceived) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Caller)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.SourceDomain != 0 {
		n += 1 + sovEvents(uint64(m.SourceDomain))
	}
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MessageBody)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MaxMessageBodySizeUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewMaxMessageBodySize != 0 {
		n += 1 + sovEvents(uint64(m.NewMaxMessageBodySize))
	}
	return n
}

func (m *RemoteTokenMessengerAdded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != 0 {
		n += 1 + sovEvents(uint64(m.Domain))
	}
	l = len(m.TokenMessenger)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *RemoteTokenMessengerRemoved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != 0 {
		n += 1 + sovEvents(uint64(m.Domain))
	}
	l = len(m.TokenMessenger)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AttesterEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttesterEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttesterEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttesterDisabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttesterDisabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttesterDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureThresholdUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureThresholdUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureThresholdUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldSignatureThreshold", wireType)
			}
			m.OldSignatureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldSignatureThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSignatureThreshold", wireType)
			}
			m.NewSignatureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSignatureThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorityUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorityUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorityUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PauseBurningAndMinting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PauseBurningAndMinting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PauseBurningAndMinting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnpauseBurningAndMinting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnpauseBurningAndMinting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnpauseBurningAndMinting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PauseSendingAndReceiving) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PauseSendingAndReceiving: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PauseSendingAndReceiving: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnpauseSendingAndReceiving) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnpauseSendingAndReceiving: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnpauseSendingAndReceiving: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositForBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositForBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositForBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintRecipient", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintRecipient = append(m.MintRecipient[:0], dAtA[iNdEx:postIndex]...)
			if m.MintRecipient == nil {
				m.MintRecipient = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
			}
			m.DestinationDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationTokenMessenger", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationTokenMessenger = append(m.DestinationTokenMessenger[:0], dAtA[iNdEx:postIndex]...)
			if m.DestinationTokenMessenger == nil {
				m.DestinationTokenMessenger = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCaller", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationCaller = append(m.DestinationCaller[:0], dAtA[iNdEx:postIndex]...)
			if m.DestinationCaller == nil {
				m.DestinationCaller = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MintAndWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MintAndWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MintAndWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintRecipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintRecipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenPairLinked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenPairLinked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenPairLinked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDomain", wireType)
			}
			m.RemoteDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenPairUnlinked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenPairUnlinked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenPairUnlinked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDomain", wireType)
			}
			m.RemoteDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageSent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageSent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageSent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageReceived) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageReceived: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageReceived: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceDomain", wireType)
			}
			m.SourceDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageBody = append(m.MessageBody[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageBody == nil {
				m.MessageBody = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxMessageBodySizeUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxMessageBodySizeUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxMessageBodySizeUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMaxMessageBodySize", wireType)
			}
			m.NewMaxMessageBodySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewMaxMessageBodySize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteTokenMessengerAdded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteTokenMessengerAdded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteTokenMessengerAdded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMessenger", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenMessenger = append(m.TokenMessenger[:0], dAtA[iNdEx:postIndex]...)
			if m.TokenMessenger == nil {
				m.TokenMessenger = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteTokenMessengerRemoved) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteTokenMessengerRemoved: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteTokenMessengerRemoved: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMessenger", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenMessenger = append(m.TokenMessenger[:0], dAtA[iNdEx:postIndex]...)
			if m.TokenMessenger == nil {
				m.TokenMessenger = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
